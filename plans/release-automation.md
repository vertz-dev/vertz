# Release Automation Plan

## Status: Draft
## Date: 2026-02-08

---

## 1. Tool Selection: Changesets

### Decision: Use [Changesets](https://github.com/changesets/changesets)

**Why Changesets over semantic-release:**

| Criteria | Changesets | semantic-release |
|---|---|---|
| Monorepo support | First-class, built for monorepos | Bolted on, one-package-per-repo origin |
| Inter-package deps | Automatic dependent bumps | Manual configuration per package |
| Human review | Version PR with changelog preview | Fully automated, no review step |
| Adoption | Hono, tRPC, Turborepo, Radix UI, Chakra UI | Single-package repos, some monorepos |
| Commit convention | Optional (changeset files instead) | Mandatory conventional commits |
| Learning curve | Low — `changeset add` wizard | Medium — commit message discipline |

**Key reasons:**
1. **Monorepo-native** — Changesets understands workspace dependencies out of the box. When `@vertz/schema` bumps, it knows `@vertz/core` (which depends on it) needs a patch bump too.
2. **Review before release** — The version PR lets maintainers review changelogs and version bumps before they go live. Critical for a young framework where messaging matters.
3. **Industry standard** — Hono, tRPC, and most modern TypeScript frameworks use changesets. Contributors will already know the workflow.
4. **No commit convention enforcement needed** — Changesets use markdown files instead of parsing commit messages. This avoids the overhead of commitlint/husky for a small team.

### What we will NOT add (and why):
- **commitlint / husky** — Conventional commits are nice but add friction. Changesets decouple versioning from commit messages, so this is unnecessary overhead.
- **semantic-release** — Overkill for a monorepo; poor monorepo support without extensive plugin configuration.
- **Lerna** — Legacy tool, changesets is the modern replacement.

---

## 2. Versioning Strategy: Fixed

### Decision: All `@vertz/*` packages share the same version number

**Configuration:** Use the `fixed` option in changesets config:
```json
{
  "fixed": [["@vertz/schema", "@vertz/core", "@vertz/compiler", "@vertz/testing"]]
}
```

**Why fixed over independent:**
- Vertz is a **cohesive framework**, not a collection of unrelated utilities. Users install multiple `@vertz/*` packages together.
- Fixed versions eliminate "which versions are compatible?" confusion. If you have `@vertz/core@0.3.0`, you know `@vertz/testing@0.3.0` works with it.
- Hono uses fixed versioning. Effect-TS uses fixed versioning. Frameworks that are used together should version together.
- The packages have tight coupling: `core` depends on `schema`, `testing` depends on `core`. Independent versions would create a compatibility matrix nightmare.

**Trade-off:** A change to only `@vertz/schema` will bump all four packages. This is acceptable because:
- Users expect framework packages to move in lockstep
- It simplifies the mental model
- The packages are small enough that publishing unchanged packages is negligible

---

## 3. Changelog Generation

### Decision: Use `@changesets/changelog-github`

**Configuration in `.changeset/config.json`:**
```json
{
  "changelog": ["@changesets/changelog-github", { "repo": "vertz-dev/vertz" }]
}
```

**What this gives us:**
- Each CHANGELOG.md entry links to the PR that introduced the change
- Links to the GitHub user who authored the change
- Consistent formatting across all packages

**Each package gets its own `CHANGELOG.md`** in its directory, auto-generated by `changeset version`.

---

## 4. GitHub Releases + Tags

### Decision: Automatic via changesets/action

The `changesets/action` GitHub Action has `createGithubReleases: true` by default. When the release workflow publishes packages, it automatically:
1. Creates git tags (e.g., `@vertz/core@0.3.0`)
2. Creates GitHub Releases with the changelog content

Since we use fixed versioning, we will also get a unified release tag.

---

## 5. CI Workflow for Automated Publishing

### New workflow: `.github/workflows/release.yml`

```yaml
name: Release

on:
  push:
    branches: [main]

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    permissions:
      contents: write       # Create releases, push tags
      pull-requests: write   # Create version PRs
      id-token: write        # npm provenance via OIDC

    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - run: bun install --frozen-lockfile

      - name: Build all packages
        run: bun run build

      - name: Create Release PR or Publish
        id: changesets
        uses: changesets/action@v1
        with:
          version: bun run changeset:version
          publish: bun run changeset:publish
          title: "chore: version packages"
          commit: "chore: version packages"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
```

### How the workflow works:

1. **When changesets exist:** The action creates/updates a "Version Packages" PR that bumps versions and updates changelogs.
2. **When the Version PR is merged:** The action detects no pending changesets and runs the `publish` command, publishing to npm.
3. **On every push to main without changesets:** Nothing happens (no-op).

### npm Provenance

The `id-token: write` permission enables npm provenance via OIDC. This provides supply chain security — users can verify that published packages were built from this specific GitHub repo and workflow. When using npm trusted publishing (recommended), provenance attestations are generated automatically.

---

## 6. Pre-release Workflow

### Approach: Changesets pre-release mode

For alpha/beta/rc releases:

```bash
# Enter pre-release mode
bunx changeset pre enter alpha

# Add changesets and version as normal
bunx changeset
bunx changeset version
# This produces versions like 0.2.0-alpha.0, 0.2.0-alpha.1, etc.

# Publish pre-release
bun run changeset:publish

# Exit pre-release mode when ready
bunx changeset pre exit
```

### Snapshot releases (for PR testing):

Changesets supports snapshot releases for testing unreleased changes:

```bash
bunx changeset version --snapshot canary
bun run changeset:publish --tag canary
# Produces versions like 0.0.0-canary-20260208T120000
```

This can be automated via a separate GitHub Actions workflow triggered by PR comments.

---

## 7. npm Org Setup Requirements

Before the first publish, the following must be set up:

### npm Organization
1. Create the `@vertz` npm organization at npmjs.com (if not already created)
2. Ensure all 4 package names are available: `@vertz/schema`, `@vertz/core`, `@vertz/compiler`, `@vertz/testing`

### npm Authentication
**Option A: Access Token (simpler)**
1. Generate an npm access token (Automation type — no 2FA prompt)
2. Add it as `NPM_TOKEN` secret in the GitHub repo settings

**Option B: Trusted Publishing (more secure, recommended)**
1. Configure trusted publishing on npmjs.com for each package
2. Set the GitHub Actions workflow file as the trusted publisher
3. No long-lived tokens needed — uses OIDC

### GitHub Repository
1. Ensure `GITHUB_TOKEN` has write access to contents and PRs (default for GitHub Actions)
2. No additional secrets needed beyond `NPM_TOKEN` (or trusted publishing config)

---

## 8. Package.json Readiness

Each package needs these fields for publishing:

```json
{
  "name": "@vertz/core",
  "version": "0.1.0",
  "type": "module",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/vertz-dev/vertz.git",
    "directory": "packages/core"
  },
  "publishConfig": {
    "access": "public",
    "provenance": true
  },
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": { ... },
  "files": ["dist"],
  "engines": { "node": ">=22" }
}
```

**What needs to be added to each package:**
- `license` field (MIT)
- `repository` field with `directory`
- `publishConfig` with `access: "public"` and `provenance: true`

**What already exists and is correct:**
- `name`, `version`, `type`, `main`, `types`, `exports`, `files`, `engines`

---

## 9. Step-by-Step Implementation Guide

### Step 1: Install changesets
```bash
bun add -D -w @changesets/cli @changesets/changelog-github
```

### Step 2: Initialize changesets
```bash
bunx changeset init
```
This creates `.changeset/` directory with `config.json` and `README.md`.

### Step 3: Configure `.changeset/config.json`
```json
{
  "$schema": "https://unpkg.com/@changesets/config@3.1.1/schema.json",
  "changelog": ["@changesets/changelog-github", { "repo": "vertz-dev/vertz" }],
  "commit": false,
  "fixed": [["@vertz/schema", "@vertz/core", "@vertz/compiler", "@vertz/testing"]],
  "linked": [],
  "access": "public",
  "baseBranch": "main",
  "updateInternalDependencies": "patch",
  "ignore": [],
  "bumpVersionsWithWorkspaceProtocolOnly": true
}
```

### Step 4: Add scripts to root package.json
```json
{
  "scripts": {
    "changeset": "changeset",
    "changeset:version": "changeset version",
    "changeset:publish": "bun run build && changeset publish"
  }
}
```

### Step 5: Update each package.json
Add `license`, `repository`, and `publishConfig` fields to all four packages.

### Step 6: Create release workflow
Add `.github/workflows/release.yml` (as described in section 5).

### Step 7: Create RELEASING.md
Document the release process for contributors.

### Step 8: Verify
- Run `bunx changeset` to create a test changeset
- Run `bunx changeset version` to verify version bumping works
- Verify changelogs are generated
- Delete the test changeset and revert version changes

---

## 10. Dependency Graph

Understanding the publish order matters:

```
@vertz/schema (no deps)
    ↓
@vertz/core (depends on schema)
    ↓
@vertz/testing (depends on core)

@vertz/compiler (depends on ts-morph, no @vertz deps)
```

Changesets handles this automatically with `workspace:*` protocol. When publishing:
1. `workspace:*` is replaced with the actual version (e.g., `^0.2.0`)
2. Packages are published in dependency order
3. If `schema` changes, `core` and `testing` get patch bumps automatically (via `updateInternalDependencies: "patch"`)

With fixed versioning, all four packages always get the same version regardless of which one changed.

---

## 11. Developer Workflow Summary

### For contributors:
```bash
# 1. Make your changes on a feature branch
git checkout -b feat/my-feature

# 2. Add a changeset describing the change
bunx changeset
# Interactive: select packages, bump type, description

# 3. Commit the changeset file along with your code
git add .changeset/
git commit -m "feat: my feature"

# 4. Open a PR
```

### For maintainers (release):
```bash
# 1. Merge PRs with changesets into main
# 2. The Release workflow creates a "Version Packages" PR automatically
# 3. Review the version bumps and changelog
# 4. Merge the Version PR
# 5. The Release workflow publishes to npm automatically
```

No manual `npm publish` needed. The entire release is driven by merging PRs.
