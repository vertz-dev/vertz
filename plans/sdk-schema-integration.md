# SDK Schema Integration

> Design doc for [#486](https://github.com/vertz-dev/vertz/issues/486)

## 1. API Surface

### Before (current state)

```tsx
import { s } from '@vertz/schema';

// Developer manually defines validation — duplicates entity definition
const createTodoSchema = s.object({
  title: s.string().min(1),
  completed: s.boolean().optional(),
});

const todoForm = form(todoApi.create, { schema: createTodoSchema });
```

### After (end state)

```tsx
// Generated SDK carries .meta.bodySchema — no manual schema needed
const todoForm = form(api.todos.create);

const { action, method, onSubmit } = todoForm.attrs({
  onSuccess: props.onSuccess,
  resetOnSuccess: true,
});

return (
  <form action={action} method={method} onSubmit={onSubmit}>
    <input name="title" type="text" />
    <span>{todoForm.error('title')}</span>
    <button type="submit" disabled={todoForm.submitting.value}>
      {todoForm.submitting.value ? 'Adding...' : 'Add Todo'}
    </button>
  </form>
) as HTMLFormElement;
```

### Type-safe enforcement

When the SDK method has `.meta.bodySchema`, `form()` options are fully optional. When it does NOT, `schema` is **required** — enforced at compile time via function overloads:

```ts
// SDK method WITH meta.bodySchema — options optional
const f1 = form(api.todos.create);                    // OK
const f2 = form(api.todos.create, { schema: custom }); // OK (override)

// SDK method WITHOUT meta — schema required
const f3 = form(legacySdk);                // TYPE ERROR
const f4 = form(legacySdk, { schema });    // OK
```

This prevents silent no-validation, which would violate "if it builds, it works."

### Generated SDK output

```ts
// Generated by @vertz/codegen — do not edit
import { createTodosInputSchema, updateTodosInputSchema } from '../schemas/todos';
import type { CreateTodosInput, UpdateTodosInput, TodosResponse } from '../types';
import type { Client } from '../client';

export function createTodosSdk(client: Client) {
  return {
    list: (query?: Record<string, unknown>) =>
      client.get<TodosResponse[]>('/todos', { query }),

    get: (id: string) =>
      client.get<TodosResponse>(`/todos/${id}`),

    create: Object.assign(
      (body: CreateTodosInput) => client.post<TodosResponse>('/todos', body),
      {
        url: '/todos',
        method: 'POST' as const,
        meta: { bodySchema: createTodosInputSchema },
      },
    ),

    update: (id: string, body: UpdateTodosInput) =>
      client.patch<TodosResponse>(`/todos/${id}`, body),

    delete: (id: string) =>
      client.delete<TodosResponse>(`/todos/${id}`),
  };
}
```

### Generated schema output

```ts
// Generated by @vertz/codegen — do not edit
import { s } from '@vertz/schema';

export const createTodosInputSchema = s.object({
  title: s.string(),
  completed: s.boolean().optional(),
});

export const updateTodosInputSchema = s.object({
  title: s.string().optional(),
  completed: s.boolean().optional(),
});
```

---

## 2. Manifesto Alignment

### "If your code builds, it runs"

The function overloads enforce that a schema always exists at compile time. `form(sdkWithoutMeta)` is a type error, not a silent pass-through. No runtime surprise.

### "One Way to Do Things"

Auto-schema is the primary path. Explicit schema is the escape hatch for customization. Documentation frames it this way: "The SDK carries your schema. Override with `{ schema }` only when you need custom client-side rules."

### "Explicit over implicit"

The `.meta.bodySchema` property is visible in IDE hover and TypeScript types. Auto-extraction is discoverable through the type system. The developer sees `.meta` in the type signature — it's explicit at the API level, automatic at the usage level.

### "Compile-time over runtime"

`validate()` handles `@vertz/schema` ParseError via duck-typing (`.issues` array check) — no runtime `instanceof` across package boundaries. Schema resolution is compile-time typed.

### Alternative considered: require schema always

Rejected. This defeats the purpose of codegen. If the SDK already carries the schema, asking the developer to repeat it violates DRY and makes the LLM's job harder. The auto-extraction is the "wow moment" for the framework.

---

## 3. Non-Goals

- **`update` operations in `form()`** — `update(id, body)` takes 2 arguments, doesn't fit `SdkMethod<TBody, TResult>` (single-arg callable). Update forms need ID from context + explicit schema. Tracked separately if needed.
- **Constraint-aware schema generation** — Generated schemas validate types (`s.string()`, `s.boolean()`) but NOT column constraints (max length, email format, min value). Server-side `deriveSchemas()` in `@vertz/db` already provides constraint-aware validation. Adding constraints to codegen requires piping column metadata through the IR — deferred to a follow-up.
- **Partial schema override** — No mechanism to extend auto-schema with extra rules. Write a full custom schema instead.
- **`query()` integration via `.meta.queryKey`** — Separate concern, separate issue.
- **Breaking existing `form()` callers** — All existing `form(sdk, { schema })` calls continue to work unchanged.

---

## 4. Unknowns

### 4.1 ts-morph type navigation for schema properties — Needs POC

**Question:** Can ts-morph reliably extract field-level info (name, type, optionality) from the resolved TypeScript types of `createInput` / `updateInput`?

**Risk:** The resolved type is `SchemaLike<T>`, not `T` directly. We need to navigate through `parse()`'s return type. Also, `d.table()` uses mapped types and conditional types internally — ts-morph may resolve to opaque types.

**Resolution strategy:** POC in Phase 3 implementation. If ts-morph can't resolve fields, fallback is generating schemas from JSON Schema (already available in some code paths) or from column metadata in the IR.

### 4.2 Date serialization in JSON — Discussion-resolvable

**Question:** `d.timestamp()` resolves to `Date` at the TypeScript level, but JSON serializes to ISO string. Should generated schemas use `s.date()` or `s.string()` (with ISO format)?

**Resolution:** Use `s.string()` for date fields in generated client-side schemas. The JSON transport layer always delivers strings. The SDK methods work with JSON, not Date objects. Document this mapping.

---

## 5. POC Results

### 5.1 ts-morph type navigation — Resolved (POC succeeded)

**Question:** Can ts-morph reliably extract field-level info from the resolved TypeScript types of `createInput` / `updateInput`?

**What was tried:** In Phase 3 (`packages/compiler/src/analyzers/entity-analyzer.ts`), the `resolveFieldsFromSchemaType()` method navigates the type chain: `SchemaLike<T>` property → get `parse` member → get call signatures → get return type `T` → call `T.getProperties()`. Each property is then mapped via `mapTsType()` which checks `isString()`, `isNumber()`, `isBoolean()`, and `getText() === 'Date'`, with union-type handling for `T | undefined` (optional fields).

**What was learned:**
- ts-morph resolves `Partial<T>` and other mapped types correctly — `getProperties()` returns the resolved fields with optionality intact.
- Union types like `string | undefined` are handled by filtering out `undefined` from union members.
- Array types (`string[]`) and complex object types degrade to `'unknown'` — this is acceptable for the initial implementation since generated schemas only validate primitive types.
- The `Date` type maps to `'date'` which the schema generator emits as `s.string()` (JSON transport delivers ISO strings).

**How the design changed:** No design changes needed. The ts-morph approach works as proposed. The fallback strategy (generating schemas from JSON Schema) was not needed.

---

## 6. Type Flow Map

```
SdkMethod<TBody, TResult>.meta.bodySchema: FormSchema<TBody>
  → form<TBody, TResult>(sdkMethod)
    → resolvedSchema = options?.schema ?? sdkMethod.meta?.bodySchema
    → validate<TBody>(resolvedSchema, data)
      → handles ParseError.issues → Record<string, string>
    → FormInstance<TBody, TResult>
      → error(field: keyof TBody & string) → string | undefined
      → attrs().onSubmit → validates with resolvedSchema
      → handleSubmit() → validates with resolvedSchema
```

**Type flow paths to test:**
1. `TBody` flows: `SdkMethod.meta.bodySchema` → `form()` infers `TBody` → `error(keyof TBody)` constrains field names
2. `TResult` flows: `SdkMethod` return type → `SubmitCallbacks.onSuccess(result: TResult)`
3. **Negative:** `form(sdkWithoutMeta)` without explicit schema → compile error
4. **Negative:** `form(sdkWithMeta, { schema: wrongType })` → compile error

---

## 7. E2E Acceptance Test

Written as a failing test in `packages/integration-tests/` using public package imports:

```ts
import { form } from '@vertz/ui/form';
import { s } from '@vertz/schema';

// Mock SDK method with .meta.bodySchema (simulates generated SDK)
const schema = s.object({ title: s.string().min(1) });
const createTodo = Object.assign(
  async (body: { title: string }) => ({ id: '1', ...body }),
  { url: '/todos', method: 'POST', meta: { bodySchema: schema } },
);

// 1. form() works without explicit schema
const f = form(createTodo);

// 2. Validation works (empty title fails)
const fd = new FormData();
fd.append('title', '');
await f.handleSubmit({ onError: (errors) => {
  expect(errors.title).toBeDefined();       // field error from schema
} })(fd);

// 3. Valid submission passes through
fd.set('title', 'Buy milk');
await f.handleSubmit({ onSuccess: (result) => {
  expect(result.id).toBe('1');              // SDK method called
} })(fd);

// 4. Type safety: form() without schema on plain SDK is a type error
// @ts-expect-error — SDK without .meta requires explicit schema
form(plainSdkWithoutMeta);
```

---

## 8. Implementation Plan

See GitHub issues #487–#492 for detailed implementation phases.

### PR Structure

| PR | Scope | Packages | Phases |
|---|---|---|---|
| **PR 1** | validate() + form() auto-schema | `@vertz/ui` | Phases 1–2 |
| **PR 2** | Compiler IR + codegen | `@vertz/compiler`, `@vertz/codegen` | Phases 3–5 |
| **PR 3** | Entity-todo example | `examples/entity-todo` | Phase 6 |
