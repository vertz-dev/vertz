import { writeFile } from 'node:fs/promises';
import { relative } from 'node:path';
import type { AppIR } from '../ir/types';
import { BaseGenerator } from './base-generator';

export interface BootModuleEntry {
  name: string;
  importPath: string;
  variableName: string;
  options?: Record<string, unknown>;
}

export interface BootMiddlewareEntry {
  name: string;
  importPath: string;
  variableName: string;
}

export interface BootManifest {
  initializationOrder: string[];
  modules: BootModuleEntry[];
  globalMiddleware: BootMiddlewareEntry[];
}

export function buildBootManifest(ir: AppIR): BootManifest {
  const moduleMap = new Map(ir.modules.map((m) => [m.name, m]));
  const registrationMap = new Map(ir.app.moduleRegistrations.map((r) => [r.moduleName, r]));

  const modules: BootModuleEntry[] = [];
  for (const name of ir.dependencyGraph.initializationOrder) {
    const mod = moduleMap.get(name);
    if (!mod) continue;
    const reg = registrationMap.get(name);
    modules.push({
      name: mod.name,
      importPath: mod.sourceFile,
      variableName: `${mod.name}Module`,
      ...(reg?.options && { options: reg.options }),
    });
  }

  const globalMiddleware: BootMiddlewareEntry[] = ir.app.globalMiddleware.map((ref) => ({
    name: ref.name,
    importPath: ref.sourceFile,
    variableName: ref.name,
  }));

  return {
    initializationOrder: ir.dependencyGraph.initializationOrder,
    modules,
    globalMiddleware,
  };
}

export function resolveImportPath(from: string, to: string): string {
  const rel = relative(from, to).replace(/\.ts$/, '');
  return rel.startsWith('.') ? rel : `./${rel}`;
}

export function renderBootFile(manifest: BootManifest, outputDir: string): string {
  const lines: string[] = [];
  lines.push('// Auto-generated by @vertz/compiler â€” do not edit');

  for (const mod of manifest.modules) {
    const importPath = resolveImportPath(outputDir, mod.importPath);
    lines.push(`import { ${mod.variableName} } from '${importPath}';`);
  }
  for (const mw of manifest.globalMiddleware) {
    const importPath = resolveImportPath(outputDir, mw.importPath);
    lines.push(`import { ${mw.variableName} } from '${importPath}';`);
  }

  lines.push('');
  lines.push('export const bootSequence = {');
  lines.push(
    `  initializationOrder: [${manifest.initializationOrder.map((n) => `'${n}'`).join(', ')}],`,
  );

  lines.push('  modules: {');
  for (const mod of manifest.modules) {
    if (mod.options) {
      lines.push(
        `    ${mod.name}: { module: ${mod.variableName}, options: ${JSON.stringify(mod.options)} },`,
      );
    } else {
      lines.push(`    ${mod.name}: { module: ${mod.variableName} },`);
    }
  }
  lines.push('  },');

  lines.push(
    `  globalMiddleware: [${manifest.globalMiddleware.map((mw) => mw.variableName).join(', ')}],`,
  );
  lines.push('} as const;');
  lines.push('');

  return lines.join('\n');
}

export class BootGenerator extends BaseGenerator {
  readonly name = 'boot';

  async generate(ir: AppIR, outputDir: string): Promise<void> {
    const manifest = buildBootManifest(ir);
    const content = renderBootFile(manifest, outputDir);
    const outputPath = this.resolveOutputPath(outputDir, 'boot.ts');
    await writeFile(outputPath, content);
  }
}
