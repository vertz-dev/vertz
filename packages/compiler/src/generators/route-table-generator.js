import { writeFile } from 'node:fs/promises';
import { BaseGenerator } from './base-generator';

function schemaRefName(ref) {
  if (!ref || ref.kind !== 'named') return undefined;
  return ref.schemaName;
}
export function buildRouteTable(ir) {
  const routes = [];
  for (const mod of ir.modules) {
    for (const router of mod.routers) {
      for (const route of router.routes) {
        routes.push({
          method: route.method,
          path: route.fullPath,
          operationId: route.operationId,
          moduleName: mod.name,
          routerName: router.name,
          middleware: route.middleware.map((m) => m.name),
          schemas: {
            params: schemaRefName(route.params),
            query: schemaRefName(route.query),
            body: schemaRefName(route.body),
            headers: schemaRefName(route.headers),
            response: schemaRefName(route.response),
          },
        });
      }
    }
  }
  routes.sort((a, b) => a.path.localeCompare(b.path) || a.method.localeCompare(b.method));
  return { routes };
}
export function renderRouteTableFile(manifest) {
  const lines = [
    '// Auto-generated by @vertz/compiler â€” do not edit',
    "import type { HttpMethod } from '@vertz/compiler';",
    '',
    'export interface RouteTableEntry {',
    '  method: HttpMethod;',
    '  path: string;',
    '  operationId: string;',
    '  moduleName: string;',
    '  routerName: string;',
    '  middleware: string[];',
    '  schemas: {',
    '    params?: string;',
    '    query?: string;',
    '    body?: string;',
    '    headers?: string;',
    '    response?: string;',
    '  };',
    '}',
    '',
    'export const routeTable: RouteTableEntry[] = [',
  ];
  for (const route of manifest.routes) {
    lines.push('  {');
    lines.push(`    method: '${route.method}',`);
    lines.push(`    path: '${route.path}',`);
    lines.push(`    operationId: '${route.operationId}',`);
    lines.push(`    moduleName: '${route.moduleName}',`);
    lines.push(`    routerName: '${route.routerName}',`);
    lines.push(`    middleware: [${route.middleware.map((m) => `'${m}'`).join(', ')}],`);
    lines.push('    schemas: {');
    for (const [key, value] of Object.entries(route.schemas)) {
      if (value !== undefined) {
        lines.push(`      ${key}: '${value}',`);
      }
    }
    lines.push('    },');
    lines.push('  },');
  }
  lines.push('];');
  lines.push('');
  return lines.join('\n');
}
export class RouteTableGenerator extends BaseGenerator {
  name = 'route-table';
  async generate(ir, outputDir) {
    const manifest = buildRouteTable(ir);
    const content = renderRouteTableFile(manifest);
    const outputPath = this.resolveOutputPath(outputDir, 'routes.ts');
    await writeFile(outputPath, content);
  }
}
//# sourceMappingURL=route-table-generator.js.map
