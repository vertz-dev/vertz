import { writeFile } from 'node:fs/promises';
import { relative } from 'node:path';
import { BaseGenerator } from './base-generator';
export function buildBootManifest(ir) {
  const moduleMap = new Map(ir.modules.map((m) => [m.name, m]));
  const registrationMap = new Map(ir.app.moduleRegistrations.map((r) => [r.moduleName, r]));
  const modules = [];
  for (const name of ir.dependencyGraph.initializationOrder) {
    const mod = moduleMap.get(name);
    if (!mod) continue;
    const reg = registrationMap.get(name);
    modules.push({
      name: mod.name,
      importPath: mod.sourceFile,
      variableName: `${mod.name}Module`,
      ...(reg?.options && { options: reg.options }),
    });
  }
  const globalMiddleware = ir.app.globalMiddleware.map((ref) => ({
    name: ref.name,
    importPath: ref.sourceFile,
    variableName: ref.name,
  }));
  return {
    initializationOrder: ir.dependencyGraph.initializationOrder,
    modules,
    globalMiddleware,
  };
}
export function resolveImportPath(from, to) {
  const rel = relative(from, to).replace(/\.ts$/, '');
  return rel.startsWith('.') ? rel : `./${rel}`;
}
export function renderBootFile(manifest, outputDir) {
  const lines = [];
  lines.push('// Auto-generated by @vertz/compiler â€” do not edit');
  for (const mod of manifest.modules) {
    const importPath = resolveImportPath(outputDir, mod.importPath);
    lines.push(`import { ${mod.variableName} } from '${importPath}';`);
  }
  for (const mw of manifest.globalMiddleware) {
    const importPath = resolveImportPath(outputDir, mw.importPath);
    lines.push(`import { ${mw.variableName} } from '${importPath}';`);
  }
  lines.push('');
  lines.push('export const bootSequence = {');
  lines.push(
    `  initializationOrder: [${manifest.initializationOrder.map((n) => `'${n}'`).join(', ')}],`,
  );
  lines.push('  modules: {');
  for (const mod of manifest.modules) {
    if (mod.options) {
      lines.push(
        `    ${mod.name}: { module: ${mod.variableName}, options: ${JSON.stringify(mod.options)} },`,
      );
    } else {
      lines.push(`    ${mod.name}: { module: ${mod.variableName} },`);
    }
  }
  lines.push('  },');
  lines.push(
    `  globalMiddleware: [${manifest.globalMiddleware.map((mw) => mw.variableName).join(', ')}],`,
  );
  lines.push('} as const;');
  lines.push('');
  return lines.join('\n');
}
export class BootGenerator extends BaseGenerator {
  name = 'boot';
  async generate(ir, outputDir) {
    const manifest = buildBootManifest(ir);
    const content = renderBootFile(manifest, outputDir);
    const outputPath = this.resolveOutputPath(outputDir, 'boot.ts');
    await writeFile(outputPath, content);
  }
}
//# sourceMappingURL=boot-generator.js.map
