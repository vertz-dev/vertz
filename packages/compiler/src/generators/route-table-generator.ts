import { writeFile } from 'node:fs/promises';
import type { AppIR, HttpMethod, SchemaRef } from '../ir/types';
import { BaseGenerator } from './base-generator';

export interface RouteTableSchemas {
  params?: string;
  query?: string;
  body?: string;
  headers?: string;
  response?: string;
}

export interface RouteTableEntry {
  method: HttpMethod;
  path: string;
  operationId: string;
  moduleName: string;
  routerName: string;
  middleware: string[];
  schemas: RouteTableSchemas;
}

export interface RouteTableManifest {
  routes: RouteTableEntry[];
}

function schemaRefName(ref: SchemaRef | undefined): string | undefined {
  if (!ref || ref.kind !== 'named') return undefined;
  return ref.schemaName;
}

export function buildRouteTable(ir: AppIR): RouteTableManifest {
  const routes: RouteTableEntry[] = [];

  for (const mod of ir.modules) {
    for (const router of mod.routers) {
      for (const route of router.routes) {
        routes.push({
          method: route.method,
          path: route.fullPath,
          operationId: route.operationId,
          moduleName: mod.name,
          routerName: router.name,
          middleware: route.middleware.map((m) => m.name),
          schemas: {
            params: schemaRefName(route.params),
            query: schemaRefName(route.query),
            body: schemaRefName(route.body),
            headers: schemaRefName(route.headers),
            response: schemaRefName(route.response),
          },
        });
      }
    }
  }

  routes.sort((a, b) => a.path.localeCompare(b.path) || a.method.localeCompare(b.method));

  return { routes };
}

export function renderRouteTableFile(manifest: RouteTableManifest): string {
  const lines: string[] = [
    '// Auto-generated by @vertz/compiler â€” do not edit',
    "import type { HttpMethod } from '@vertz/compiler';",
    '',
    'export interface RouteTableEntry {',
    '  method: HttpMethod;',
    '  path: string;',
    '  operationId: string;',
    '  moduleName: string;',
    '  routerName: string;',
    '  middleware: string[];',
    '  schemas: {',
    '    params?: string;',
    '    query?: string;',
    '    body?: string;',
    '    headers?: string;',
    '    response?: string;',
    '  };',
    '}',
    '',
    'export const routeTable: RouteTableEntry[] = [',
  ];

  for (const route of manifest.routes) {
    lines.push('  {');
    lines.push(`    method: '${route.method}',`);
    lines.push(`    path: '${route.path}',`);
    lines.push(`    operationId: '${route.operationId}',`);
    lines.push(`    moduleName: '${route.moduleName}',`);
    lines.push(`    routerName: '${route.routerName}',`);
    lines.push(`    middleware: [${route.middleware.map((m) => `'${m}'`).join(', ')}],`);
    lines.push('    schemas: {');
    for (const [key, value] of Object.entries(route.schemas)) {
      if (value !== undefined) {
        lines.push(`      ${key}: '${value}',`);
      }
    }
    lines.push('    },');
    lines.push('  },');
  }

  lines.push('];');
  lines.push('');

  return lines.join('\n');
}

export class RouteTableGenerator extends BaseGenerator {
  readonly name = 'route-table';

  async generate(ir: AppIR, outputDir: string): Promise<void> {
    const manifest = buildRouteTable(ir);
    const content = renderRouteTableFile(manifest);
    const outputPath = this.resolveOutputPath(outputDir, 'routes.ts');
    await writeFile(outputPath, content);
  }
}
