import type {
  CodegenEntityModule,
  CodegenIR,
  CodegenResolvedField,
  GeneratedFile,
  Generator,
  GeneratorConfig,
} from '../types';

const FILE_HEADER = '// Generated by @vertz/codegen â€” do not edit\n\n';

const TS_TYPE_MAP: Record<CodegenResolvedField['tsType'], string> = {
  string: 'string',
  number: 'number',
  boolean: 'boolean',
  date: 'string', // JSON transport delivers ISO strings
  unknown: 'unknown',
};

export class EntityTypesGenerator implements Generator {
  readonly name = 'entity-types';

  generate(ir: CodegenIR, _config: GeneratorConfig): GeneratedFile[] {
    if (!ir.entities?.length) return [];

    const files: GeneratedFile[] = [];
    const entitiesWithTypes: CodegenEntityModule[] = [];

    for (const entity of ir.entities) {
      const hasOpTypes = entity.operations.some((op) => op.inputSchema || op.outputSchema);
      const hasActionTypes = entity.actions.some(
        (a) => a.resolvedInputFields?.length || a.resolvedOutputFields?.length,
      );
      if (!hasOpTypes && !hasActionTypes) continue;

      entitiesWithTypes.push(entity);
      files.push(this.generateEntityTypes(entity));
    }

    if (entitiesWithTypes.length > 0) {
      files.push(this.generateIndex(entitiesWithTypes));
    }

    return files;
  }

  private generateEntityTypes(entity: CodegenEntityModule): GeneratedFile {
    const lines: string[] = [FILE_HEADER];

    // Collect unique type names already emitted to avoid duplicates
    const emitted = new Set<string>();

    for (const op of entity.operations) {
      // Emit input type (body type for create/update)
      if (op.inputSchema && !emitted.has(op.inputSchema)) {
        const inputType = this.emitBodyType(op.inputSchema, op.resolvedFields);
        if (inputType) {
          lines.push(inputType);
          lines.push('');
          emitted.add(op.inputSchema);
        }
      }

      // Emit output type (response type)
      if (op.outputSchema && !emitted.has(op.outputSchema)) {
        const outputType = this.emitResponseType(op.outputSchema, op.responseFields);
        if (outputType) {
          lines.push(outputType);
          lines.push('');
          emitted.add(op.outputSchema);
        }
      }
    }

    // Emit action input/output types
    for (const action of entity.actions) {
      if (action.inputSchema && !emitted.has(action.inputSchema)) {
        const inputType = this.emitBodyType(action.inputSchema, action.resolvedInputFields);
        if (inputType) {
          lines.push(inputType);
          lines.push('');
          emitted.add(action.inputSchema);
        }
      }

      if (action.outputSchema && !emitted.has(action.outputSchema)) {
        const outputType = this.emitResponseType(action.outputSchema, action.resolvedOutputFields);
        if (outputType) {
          lines.push(outputType);
          lines.push('');
          emitted.add(action.outputSchema);
        }
      }
    }

    return {
      path: `types/${entity.entityName}.ts`,
      content: lines.join('\n'),
    };
  }

  private emitBodyType(
    typeName: string,
    fields: CodegenResolvedField[] | undefined,
  ): string | undefined {
    if (!fields || fields.length === 0) return undefined;

    const props = fields
      .map((f) => {
        const tsType = TS_TYPE_MAP[f.tsType] ?? 'unknown';
        const optional = f.optional ? '?' : '';
        return `  ${f.name}${optional}: ${tsType}`;
      })
      .join(';\n');

    return `export interface ${typeName} {\n${props};\n}`;
  }

  private emitResponseType(
    typeName: string,
    fields: CodegenResolvedField[] | undefined,
  ): string | undefined {
    if (!fields || fields.length === 0) return undefined;

    const props = fields
      .map((f) => {
        const tsType = TS_TYPE_MAP[f.tsType] ?? 'unknown';
        const optional = f.optional ? '?' : '';
        return `  ${f.name}${optional}: ${tsType}`;
      })
      .join(';\n');

    return `export interface ${typeName} {\n${props};\n}`;
  }

  private generateIndex(entities: CodegenEntityModule[]): GeneratedFile {
    const lines: string[] = [FILE_HEADER];

    for (const entity of entities) {
      lines.push(`export * from './${entity.entityName}';`);
    }

    return { path: 'types/index.ts', content: lines.join('\n') };
  }
}
