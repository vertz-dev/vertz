import type {
  CodegenEntityModule,
  CodegenIR,
  GeneratedFile,
  Generator,
  GeneratorConfig,
} from '../types';

const FILE_HEADER = '// Generated by @vertz/codegen â€” do not edit\n\n';

function toPascalCase(s: string): string {
  return s
    .split('-')
    .map((w) => w[0]?.toUpperCase() + w.slice(1))
    .join('');
}

export class EntitySdkGenerator implements Generator {
  readonly name = 'entity-sdk';

  generate(ir: CodegenIR, _config: GeneratorConfig): GeneratedFile[] {
    if (!ir.entities?.length) return [];

    const files: GeneratedFile[] = [];

    // Individual entity SDK files
    for (const entity of ir.entities) {
      files.push(this.generateEntitySdk(entity, ir.basePath));
    }

    // Index file re-exporting all entities
    files.push(this.generateIndex(ir.entities));

    return files;
  }

  private generateEntitySdk(entity: CodegenEntityModule, _basePath: string): GeneratedFile {
    const pascal = toPascalCase(entity.entityName);
    const lines: string[] = [FILE_HEADER];

    // Import types (when schema is resolved)
    const hasTypes = entity.operations.some((op) => op.outputSchema || op.inputSchema);
    if (hasTypes) {
      const typeImports = new Set<string>();
      for (const op of entity.operations) {
        if (op.outputSchema) typeImports.add(op.outputSchema);
        if (op.inputSchema) typeImports.add(op.inputSchema);
      }
      for (const action of entity.actions) {
        if (action.inputSchema) typeImports.add(action.inputSchema);
        if (action.outputSchema) typeImports.add(action.outputSchema);
      }
      lines.push(`import type { ${[...typeImports].join(', ')} } from '../types';`);
      lines.push(`import type { Client } from '../client';`);
      lines.push('');
    }

    // Generate SDK object
    lines.push(`export function create${pascal}Sdk(client: Client) {`);
    lines.push('  return {');

    for (const op of entity.operations) {
      const inputType = op.inputSchema ?? 'unknown';
      const outputType = op.outputSchema ?? 'unknown';
      const arrayOutput = op.kind === 'list' ? `${outputType}[]` : outputType;

      switch (op.kind) {
        case 'list':
          lines.push(
            `    list: (params?: Record<string, unknown>) => client.get<${arrayOutput}>('${op.path}', { params }),`,
          );
          break;
        case 'get':
          lines.push(
            `    get: (id: string) => client.get<${outputType}>(\`${op.path.replace(':id', '${id}')}\`),`,
          );
          break;
        case 'create':
          lines.push(
            `    create: (body: ${inputType}) => client.post<${outputType}>('${op.path}', body),`,
          );
          break;
        case 'update':
          lines.push(
            `    update: (id: string, body: ${inputType}) => client.patch<${outputType}>(\`${op.path.replace(':id', '${id}')}\`, body),`,
          );
          break;
        case 'delete':
          lines.push(
            `    delete: (id: string) => client.delete<${outputType}>(\`${op.path.replace(':id', '${id}')}\`),`,
          );
          break;
      }
    }

    for (const action of entity.actions) {
      const inputType = action.inputSchema ?? 'unknown';
      const outputType = action.outputSchema ?? 'unknown';
      lines.push(
        `    ${action.name}: (id: string, body: ${inputType}) => client.post<${outputType}>(\`${action.path.replace(':id', '${id}')}\`, body),`,
      );
    }

    lines.push('  };');
    lines.push('}');

    return {
      path: `entities/${entity.entityName}.ts`,
      content: lines.join('\n'),
    };
  }

  private generateIndex(entities: CodegenEntityModule[]): GeneratedFile {
    const lines: string[] = [FILE_HEADER];
    for (const entity of entities) {
      const pascal = toPascalCase(entity.entityName);
      lines.push(`export { create${pascal}Sdk } from './${entity.entityName}';`);
    }
    return { path: 'entities/index.ts', content: lines.join('\n') };
  }
}
