import type {
  CodegenEntityModule,
  CodegenIR,
  GeneratedFile,
  Generator,
  GeneratorConfig,
} from '../types';

const FILE_HEADER = '// Generated by @vertz/codegen â€” do not edit\n\n';

function toPascalCase(s: string): string {
  return s
    .split('-')
    .map((w) => w[0]?.toUpperCase() + w.slice(1))
    .join('');
}

export class EntitySdkGenerator implements Generator {
  readonly name = 'entity-sdk';

  generate(ir: CodegenIR, _config: GeneratorConfig): GeneratedFile[] {
    if (!ir.entities?.length) return [];

    const files: GeneratedFile[] = [];

    // Individual entity SDK files
    for (const entity of ir.entities) {
      files.push(this.generateEntitySdk(entity, ir.basePath));
    }

    // Index file re-exporting all entities
    files.push(this.generateIndex(ir.entities));

    return files;
  }

  private generateEntitySdk(entity: CodegenEntityModule, _basePath: string): GeneratedFile {
    const pascal = toPascalCase(entity.entityName);
    const lines: string[] = [FILE_HEADER];

    // Check if any create operation has resolved schemas (needs schema import)
    const createOpsWithMeta = entity.operations.filter(
      (op) => op.kind === 'create' && op.resolvedFields && op.resolvedFields.length > 0,
    );
    const hasSchemaImports = createOpsWithMeta.length > 0;

    // Import schemas (when create methods have resolved fields)
    if (hasSchemaImports) {
      const schemaImports: string[] = [];
      for (const op of createOpsWithMeta) {
        const schemaVarName = `${(op.inputSchema ?? 'createInput').charAt(0).toLowerCase()}${(op.inputSchema ?? 'createInput').slice(1)}Schema`;
        schemaImports.push(schemaVarName);
      }
      lines.push(`import { ${schemaImports.join(', ')} } from '../schemas/${entity.entityName}';`);
    }

    // Import types (when schema is resolved)
    const hasTypes = entity.operations.some((op) => op.outputSchema || op.inputSchema);
    const hasListOp = entity.operations.some((op) => op.kind === 'list');
    if (hasTypes) {
      const typeImports = new Set<string>();
      for (const op of entity.operations) {
        if (op.outputSchema) typeImports.add(op.outputSchema);
        if (op.inputSchema) typeImports.add(op.inputSchema);
      }
      for (const action of entity.actions) {
        if (action.inputSchema) typeImports.add(action.inputSchema);
        if (action.outputSchema) typeImports.add(action.outputSchema);
      }
      lines.push(
        `import type { ${[...typeImports].join(', ')} } from '../types/${entity.entityName}';`,
      );
      const fetchImports = hasListOp
        ? 'type FetchClient, type ListResponse, createDescriptor'
        : 'type FetchClient, createDescriptor';
      lines.push(`import { ${fetchImports} } from '@vertz/fetch';`);
      lines.push('');
    }

    // Generate SDK object
    lines.push(`export function create${pascal}Sdk(client: FetchClient) {`);
    lines.push('  return {');

    for (const op of entity.operations) {
      const inputType = op.inputSchema ?? 'unknown';
      const outputType = op.outputSchema ?? 'unknown';
      const listOutput = op.kind === 'list' ? `ListResponse<${outputType}>` : outputType;

      switch (op.kind) {
        case 'list':
          lines.push(`    list: Object.assign(`);
          lines.push(
            `      (query?: Record<string, unknown>) => createDescriptor('GET', '${op.path}', () => client.get<${listOutput}>('${op.path}', { query }), query),`,
          );
          lines.push(`      { url: '${op.path}', method: 'GET' as const },`);
          lines.push(`    ),`);
          break;
        case 'get':
          lines.push(`    get: Object.assign(`);
          lines.push(
            `      (id: string) => createDescriptor('GET', \`${op.path.replace(':id', '${id}')}\`, () => client.get<${outputType}>(\`${op.path.replace(':id', '${id}')}\`)),`,
          );
          lines.push(`      { url: '${op.path}', method: 'GET' as const },`);
          lines.push(`    ),`);
          break;
        case 'create':
          if (op.resolvedFields && op.resolvedFields.length > 0) {
            // Use Object.assign pattern with .meta for SdkMethodWithMeta
            const schemaVarName = `${(op.inputSchema ?? 'createInput').charAt(0).toLowerCase()}${(op.inputSchema ?? 'createInput').slice(1)}Schema`;
            lines.push(`    create: Object.assign(`);
            lines.push(
              `      (body: ${inputType}) => createDescriptor('POST', '${op.path}', () => client.post<${outputType}>('${op.path}', body)),`,
            );
            lines.push(`      {`);
            lines.push(`        url: '${op.path}',`);
            lines.push(`        method: 'POST' as const,`);
            lines.push(`        meta: { bodySchema: ${schemaVarName} },`);
            lines.push(`      },`);
            lines.push(`    ),`);
          } else {
            lines.push(`    create: Object.assign(`);
            lines.push(
              `      (body: ${inputType}) => createDescriptor('POST', '${op.path}', () => client.post<${outputType}>('${op.path}', body)),`,
            );
            lines.push(`      { url: '${op.path}', method: 'POST' as const },`);
            lines.push(`    ),`);
          }
          break;
        case 'update':
          lines.push(`    update: Object.assign(`);
          lines.push(
            `      (id: string, body: ${inputType}) => createDescriptor('PATCH', \`${op.path.replace(':id', '${id}')}\`, () => client.patch<${outputType}>(\`${op.path.replace(':id', '${id}')}\`, body)),`,
          );
          lines.push(`      { url: '${op.path}', method: 'PATCH' as const },`);
          lines.push(`    ),`);
          break;
        case 'delete':
          lines.push(`    delete: Object.assign(`);
          lines.push(
            `      (id: string) => createDescriptor('DELETE', \`${op.path.replace(':id', '${id}')}\`, () => client.delete<${outputType}>(\`${op.path.replace(':id', '${id}')}\`)),`,
          );
          lines.push(`      { url: '${op.path}', method: 'DELETE' as const },`);
          lines.push(`    ),`);
          break;
      }
    }

    for (const action of entity.actions) {
      const inputType = action.inputSchema ?? 'unknown';
      const outputType = action.outputSchema ?? 'unknown';
      const method = action.method ?? 'POST';
      const methodLower = method.toLowerCase();
      const hasId = action.hasId ?? action.path.includes(':id');
      const pathExpr = hasId ? `\`${action.path.replace(':id', '${id}')}\`` : `'${action.path}'`;
      const hasBody = method === 'POST' || method === 'PUT' || method === 'PATCH';

      // Build parameters
      const params: string[] = [];
      if (hasId) params.push('id: string');
      if (hasBody) params.push(`body: ${inputType}`);
      const paramStr = params.join(', ');

      // Build client call
      const clientArgs = hasBody ? `${pathExpr}, body` : pathExpr;
      const clientCall = `client.${methodLower}<${outputType}>(${clientArgs})`;

      lines.push(`    ${action.name}: Object.assign(`);
      lines.push(
        `      (${paramStr}) => createDescriptor('${method}', ${pathExpr}, () => ${clientCall}${hasBody ? ', body' : ''}),`,
      );
      lines.push(`      { url: '${action.path}', method: '${method}' as const },`);
      lines.push('    ),');
    }

    lines.push('  };');
    lines.push('}');

    return {
      path: `entities/${entity.entityName}.ts`,
      content: lines.join('\n'),
    };
  }

  private generateIndex(entities: CodegenEntityModule[]): GeneratedFile {
    const lines: string[] = [FILE_HEADER];
    for (const entity of entities) {
      const pascal = toPascalCase(entity.entityName);
      lines.push(`export { create${pascal}Sdk } from './${entity.entityName}';`);
    }
    return { path: 'entities/index.ts', content: lines.join('\n') };
  }
}
