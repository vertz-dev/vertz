import type {
  CodegenEntityModule,
  CodegenIR,
  GeneratedFile,
  Generator,
  GeneratorConfig,
} from '../types';
import { toCamelCase, toPascalCase } from '../utils/naming';

const FILE_HEADER = '// Generated by @vertz/codegen — do not edit\n\n';

export class ClientGenerator implements Generator {
  readonly name = 'client';

  generate(ir: CodegenIR, _config: GeneratorConfig): GeneratedFile[] {
    return [this.generateClient(ir), this.generatePackageJson(), this.generateReadme(ir)];
  }

  private generateClient(ir: CodegenIR): GeneratedFile {
    const entities = ir.entities ?? [];
    const lines: string[] = [FILE_HEADER];

    if (entities.length > 0) {
      lines.push("import { FetchClient } from '@vertz/fetch';");

      for (const entity of entities) {
        const pascal = toPascalCase(entity.entityName);
        lines.push(`import { create${pascal}Sdk } from './entities/${entity.entityName}';`);
      }
      lines.push('');
    }

    lines.push('export interface ClientOptions {');
    lines.push('  baseURL?: string;');
    lines.push('  headers?: Record<string, string>;');
    lines.push('  timeoutMs?: number;');
    lines.push('}');
    lines.push('');

    lines.push('export function createClient(options: ClientOptions = {}) {');

    if (entities.length > 0) {
      lines.push(
        `  const client = new FetchClient({ baseURL: options.baseURL ?? '/api', headers: options.headers, timeoutMs: options.timeoutMs });`,
      );
      lines.push('  return {');
      for (const entity of entities) {
        const pascal = toPascalCase(entity.entityName);
        const camel = toCamelCase(entity.entityName);
        lines.push(`    ${camel}: create${pascal}Sdk(client),`);
      }
      lines.push('  };');
    } else {
      lines.push('  return {};');
    }

    lines.push('}');
    lines.push('');
    lines.push('export type Client = ReturnType<typeof createClient>;');

    return { path: 'client.ts', content: lines.join('\n') };
  }

  private generatePackageJson(): GeneratedFile {
    const pkg = {
      name: '.vertz-generated',
      private: true,
      exports: {
        '.': './client.ts',
        './types': './types/index.ts',
      },
    };

    return { path: 'package.json', content: `${JSON.stringify(pkg, null, 2)}\n` };
  }

  private generateReadme(ir: CodegenIR): GeneratedFile {
    const entities = ir.entities ?? [];
    const lines: string[] = [];

    lines.push('# Generated Client');
    lines.push('');
    lines.push('Auto-generated by `@vertz/codegen`. Do not edit manually.');
    lines.push('');
    lines.push('## Usage');
    lines.push('');
    lines.push('```typescript');
    lines.push("import { createClient } from '.vertz/generated';");
    lines.push('');
    lines.push('const client = createClient();');
    lines.push('```');
    lines.push('');
    lines.push('## Type Imports');
    lines.push('');
    lines.push('```typescript');
    lines.push("import type { ... } from '.vertz/generated/types';");
    lines.push('```');

    if (entities.length > 0) {
      lines.push('');
      lines.push('## Available Resources');
      lines.push('');
      for (const entity of entities) {
        const camel = toCamelCase(entity.entityName);
        const methods = this.getEntityMethods(entity);
        lines.push(`- \`client.${camel}\` — ${methods}`);
      }
    }

    lines.push('');

    return { path: 'README.md', content: lines.join('\n') };
  }

  private getEntityMethods(entity: CodegenEntityModule): string {
    const methods: string[] = [];
    for (const op of entity.operations) {
      methods.push(op.kind);
    }
    for (const action of entity.actions) {
      methods.push(action.name);
    }
    return methods.length > 0 ? methods.join(', ') : 'no operations';
  }
}
