import { jsonSchemaToTS } from '../../json-schema-converter';
import { toPascalCase } from '../../utils/naming';

const FILE_HEADER = '// Generated by @vertz/codegen â€” do not edit\n';
function emitTypeDeclaration(name, tsType) {
  if (tsType.startsWith('{')) {
    return `export interface ${name} ${tsType}`;
  }
  return `export type ${name} = ${tsType};`;
}
export function emitInterfaceFromSchema(schema) {
  const result = jsonSchemaToTS(schema.jsonSchema);
  const lines = [];
  // Emit extracted $defs as additional types first
  for (const [name, tsType] of result.extractedTypes) {
    lines.push(emitTypeDeclaration(name, tsType));
    lines.push('');
  }
  // JSDoc comment
  const jsdocParts = [];
  if (schema.annotations.description) {
    jsdocParts.push(schema.annotations.description);
  }
  if (schema.annotations.deprecated) {
    jsdocParts.push('@deprecated');
  }
  if (jsdocParts.length > 0) {
    lines.push(`/** ${jsdocParts.join('\n * ')} */`);
  }
  // Object types emit as interfaces; everything else as type aliases
  lines.push(emitTypeDeclaration(schema.name, result.type));
  return { content: lines.join('\n'), imports: [] };
}
export function emitOperationInputType(op) {
  const typeName = `${toPascalCase(op.operationId)}Input`;
  const imports = [];
  const slots = [];
  if (op.params) {
    const ref = op.schemaRefs.params;
    if (ref) {
      slots.push(`params: ${ref}`);
      imports.push({ from: '', name: ref, isType: true });
    } else {
      const result = jsonSchemaToTS(op.params);
      slots.push(`params: ${result.type}`);
    }
  }
  if (op.query) {
    const ref = op.schemaRefs.query;
    if (ref) {
      slots.push(`query?: ${ref}`);
      imports.push({ from: '', name: ref, isType: true });
    } else {
      const result = jsonSchemaToTS(op.query);
      slots.push(`query?: ${result.type}`);
    }
  }
  if (op.body) {
    const ref = op.schemaRefs.body;
    if (ref) {
      slots.push(`body: ${ref}`);
      imports.push({ from: '', name: ref, isType: true });
    } else {
      const result = jsonSchemaToTS(op.body);
      slots.push(`body: ${result.type}`);
    }
  }
  if (op.headers) {
    const ref = op.schemaRefs.headers;
    if (ref) {
      slots.push(`headers?: ${ref}`);
      imports.push({ from: '', name: ref, isType: true });
    } else {
      const result = jsonSchemaToTS(op.headers);
      slots.push(`headers?: ${result.type}`);
    }
  }
  // No input type needed if operation has no input slots
  if (slots.length === 0) {
    return { content: '', imports: [] };
  }
  const lines = [];
  lines.push(`/** Input for ${op.operationId} */`);
  lines.push(`export interface ${typeName} { ${slots.join('; ')} }`);
  return { content: lines.join('\n'), imports };
}
export function emitOperationResponseType(op) {
  const typeName = `${toPascalCase(op.operationId)}Response`;
  const imports = [];
  if (!op.response) {
    return {
      content: `export type ${typeName} = void;`,
      imports: [],
    };
  }
  const ref = op.schemaRefs.response;
  if (ref) {
    imports.push({ from: '', name: ref, isType: true });
    return {
      content: `export type ${typeName} = ${ref};`,
      imports,
    };
  }
  const result = jsonSchemaToTS(op.response);
  return {
    content: emitTypeDeclaration(typeName, result.type),
    imports: [],
  };
}
export function emitStreamingEventType(op) {
  if (!op.streaming) {
    return { content: '', imports: [] };
  }
  const typeName = `${toPascalCase(op.operationId)}Event`;
  if (!op.streaming.eventSchema) {
    return {
      content: `export type ${typeName} = unknown;`,
      imports: [],
    };
  }
  const result = jsonSchemaToTS(op.streaming.eventSchema);
  return {
    content: emitTypeDeclaration(typeName, result.type),
    imports: [],
  };
}
export function emitModuleTypesFile(module, schemas) {
  const sections = [FILE_HEADER];
  // Emit named schemas for this module
  for (const schema of schemas) {
    const fragment = emitInterfaceFromSchema(schema);
    if (fragment.content) {
      sections.push(fragment.content);
    }
  }
  // Emit operation types
  for (const op of module.operations) {
    const inputFragment = emitOperationInputType(op);
    if (inputFragment.content) {
      sections.push(inputFragment.content);
    }
    const responseFragment = emitOperationResponseType(op);
    if (responseFragment.content) {
      sections.push(responseFragment.content);
    }
    const streamingFragment = emitStreamingEventType(op);
    if (streamingFragment.content) {
      sections.push(streamingFragment.content);
    }
  }
  return {
    path: `types/${module.name}.ts`,
    content: sections.join('\n\n'),
  };
}
export function emitSharedTypesFile(schemas) {
  const sections = [FILE_HEADER];
  for (const schema of schemas) {
    const fragment = emitInterfaceFromSchema(schema);
    if (fragment.content) {
      sections.push(fragment.content);
    }
  }
  return {
    path: 'types/shared.ts',
    content: sections.join('\n\n'),
  };
}
//# sourceMappingURL=emit-types.js.map
