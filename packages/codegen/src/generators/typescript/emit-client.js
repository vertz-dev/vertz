import { mergeImports, renderImports } from '../../utils/imports';
import { toCamelCase, toPascalCase } from '../../utils/naming';

const FILE_HEADER = '// Generated by @vertz/codegen â€” do not edit\n';
export function emitSDKConfig(auth) {
  const imports = [{ from: '@vertz/fetch', name: 'FetchClientConfig', isType: true }];
  const fields = [];
  for (const scheme of auth.schemes) {
    if (scheme.type === 'bearer') {
      fields.push(
        '  /** Bearer token or function returning a token. */\n  token?: string | (() => string | Promise<string>);',
      );
    } else if (scheme.type === 'apiKey') {
      fields.push(
        '  /** API key or function returning a key. */\n  apiKey?: string | (() => string | Promise<string>);',
      );
    }
  }
  if (fields.length === 0) {
    return {
      content: 'export interface SDKConfig extends FetchClientConfig {}',
      imports,
    };
  }
  const content = `export interface SDKConfig extends FetchClientConfig {\n${fields.join('\n')}\n}`;
  return { content, imports };
}
export function emitAuthStrategyBuilder(auth) {
  const imports = [{ from: '@vertz/fetch', name: 'AuthStrategy', isType: true }];
  const lines = [];
  lines.push('const authStrategies: AuthStrategy[] = [...(config.authStrategies ?? [])];');
  for (const scheme of auth.schemes) {
    if (scheme.type === 'bearer') {
      lines.push(
        "if (config.token) {\n  authStrategies.push({ type: 'bearer', token: config.token });\n}",
      );
    } else if (scheme.type === 'apiKey') {
      lines.push(
        `if (config.apiKey) {\n  authStrategies.push({ type: 'apiKey', key: config.apiKey, location: '${scheme.in}', name: '${scheme.paramName}' });\n}`,
      );
    }
  }
  return { content: lines.join('\n'), imports };
}
function buildPathExpression(path) {
  if (!path.includes(':')) {
    return `'${path}'`;
  }
  // biome-ignore lint/suspicious/noTemplateCurlyInString: replacement string for regex, not a template literal
  const interpolated = path.replace(/:([a-zA-Z_][a-zA-Z0-9_]*)/g, '${input.params.$1}');
  return `\`${interpolated}\``;
}
function buildRequestOptions(op) {
  const opts = [];
  if (op.query) {
    opts.push('query: input?.query');
  }
  if (op.body) {
    opts.push('body: input.body');
  }
  if (op.headers) {
    opts.push('headers: input?.headers');
  }
  if (opts.length === 0) {
    return '';
  }
  return `, { ${opts.join(', ')} }`;
}
function hasOperationInput(op) {
  return !!(op.params || op.query || op.body || op.headers);
}
function isInputOptional(op) {
  return !op.params && !op.body;
}
export function emitOperationMethod(op) {
  const imports = [];
  const methodName = toCamelCase(op.operationId);
  const inputTypeName = `${toPascalCase(op.operationId)}Input`;
  const responseTypeName = `${toPascalCase(op.operationId)}Response`;
  const hasInput = hasOperationInput(op);
  if (hasInput) {
    const optional = isInputOptional(op);
    const inputParam = optional ? `input?: ${inputTypeName}` : `input: ${inputTypeName}`;
    imports.push({ from: '../types', name: inputTypeName, isType: true });
    imports.push({ from: '../types', name: responseTypeName, isType: true });
    const pathExpr = buildPathExpression(op.path);
    const reqOpts = buildRequestOptions(op);
    const content = `${methodName}(${inputParam}): Promise<SDKResult<${responseTypeName}>> {\n  return client.request('${op.method}', ${pathExpr}${reqOpts});\n}`;
    return { content, imports };
  }
  imports.push({ from: '../types', name: responseTypeName, isType: true });
  const pathExpr = buildPathExpression(op.path);
  const content = `${methodName}(): Promise<SDKResult<${responseTypeName}>> {\n  return client.request('${op.method}', ${pathExpr});\n}`;
  return { content, imports };
}
export function emitStreamingMethod(op) {
  const imports = [];
  const methodName = toCamelCase(op.operationId);
  const inputTypeName = `${toPascalCase(op.operationId)}Input`;
  const eventTypeName = `${toPascalCase(op.operationId)}Event`;
  const format = op.streaming?.format ?? 'sse';
  imports.push({ from: '../types', name: eventTypeName, isType: true });
  const hasInput = hasOperationInput(op);
  const pathExpr = buildPathExpression(op.path);
  const streamOpts = [];
  streamOpts.push(`method: '${op.method}'`);
  streamOpts.push(`path: ${pathExpr}`);
  if (op.query) {
    streamOpts.push('query: input?.query');
  }
  streamOpts.push(`format: '${format}'`);
  const optsStr = streamOpts.join(',\n    ');
  if (hasInput) {
    const optional = isInputOptional(op);
    const inputParam = optional ? `input?: ${inputTypeName}` : `input: ${inputTypeName}`;
    imports.push({ from: '../types', name: inputTypeName, isType: true });
    const content = `async *${methodName}(${inputParam}): AsyncGenerator<${eventTypeName}> {\n  yield* client.requestStream<${eventTypeName}>({\n    ${optsStr},\n  });\n}`;
    return { content, imports };
  }
  const content = `async *${methodName}(): AsyncGenerator<${eventTypeName}> {\n  yield* client.requestStream<${eventTypeName}>({\n    ${optsStr},\n  });\n}`;
  return { content, imports };
}
export function emitModuleFile(module) {
  const fragments = [];
  for (const op of module.operations) {
    if (op.streaming) {
      fragments.push(emitStreamingMethod(op));
    } else {
      fragments.push(emitOperationMethod(op));
    }
  }
  const allImports = mergeImports(fragments.flatMap((f) => f.imports));
  const importBlock = renderImports(allImports);
  const factoryName = `create${toPascalCase(module.name)}Module`;
  const methods = fragments.map((f) => `    ${f.content}`).join(',\n');
  const sections = [FILE_HEADER];
  if (importBlock) {
    sections.push(importBlock);
    sections.push('');
  }
  sections.push(
    `export function ${factoryName}(client: FetchClient) {\n  return {\n${methods},\n  };\n}`,
  );
  const fetchClientImport = "import { FetchClient } from '@vertz/fetch';";
  // Insert FetchClient import after the header
  const content = sections.join('\n');
  const withFetchImport = content.replace(FILE_HEADER, `${FILE_HEADER}\n${fetchClientImport}\n`);
  return {
    path: `modules/${module.name}.ts`,
    content: withFetchImport,
  };
}
export function emitClientFile(ir) {
  const sections = [FILE_HEADER];
  const imports = [];
  // Import FetchClient
  imports.push({ from: '@vertz/fetch', name: 'FetchClient', isType: false });
  // SDKConfig fragment
  const configFragment = emitSDKConfig(ir.auth);
  imports.push(...configFragment.imports);
  // Auth strategy builder
  const authFragment = emitAuthStrategyBuilder(ir.auth);
  imports.push(...authFragment.imports);
  // Module imports
  for (const mod of ir.modules) {
    const factoryName = `create${toPascalCase(mod.name)}Module`;
    imports.push({ from: `./modules/${mod.name}`, name: factoryName, isType: false });
  }
  const allImports = mergeImports(imports);
  const importBlock = renderImports(allImports);
  if (importBlock) {
    sections.push(importBlock);
    sections.push('');
  }
  // SDKResult type
  sections.push(
    'export interface SDKResult<T> {\n  data: T;\n  status: number;\n  headers: Headers;\n}',
  );
  sections.push('');
  // SDKConfig interface
  sections.push(configFragment.content);
  sections.push('');
  // createClient function
  const moduleEntries = ir.modules
    .map((mod) => `    ${toCamelCase(mod.name)}: create${toPascalCase(mod.name)}Module(client)`)
    .join(',\n');
  const createClientBody = [
    'export function createClient(config: SDKConfig) {',
    `  ${authFragment.content.split('\n').join('\n  ')}`,
    '',
    '  const client = new FetchClient({',
    '    ...config,',
    '    authStrategies,',
    '  });',
    '',
    '  return {',
    moduleEntries,
    '  };',
    '}',
  ].join('\n');
  sections.push(createClientBody);
  return {
    path: 'client.ts',
    content: sections.join('\n'),
  };
}
//# sourceMappingURL=emit-client.js.map
