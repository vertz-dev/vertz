import type {
  CodegenIR,
  CodegenModule,
  CodegenOperation,
  GeneratedFile,
  JsonSchema,
} from '../../types';
import { toKebabCase } from '../../utils/naming';

const FILE_HEADER = '// Generated by @vertz/codegen — do not edit\n';

function mapJsonSchemaTypeToCLI(type: string | undefined): string {
  if (type === 'number' || type === 'integer') return 'number';
  if (type === 'boolean') return 'boolean';
  return 'string';
}

function emitFieldDefinitions(schema: JsonSchema, indent: string): string[] {
  const properties = schema.properties as Record<string, Record<string, unknown>> | undefined;
  if (!properties) return [];

  const required = (schema.required as string[]) ?? [];
  const lines: string[] = [];

  for (const [key, propSchema] of Object.entries(properties)) {
    const cliType = mapJsonSchemaTypeToCLI(propSchema.type as string | undefined);
    const isRequired = required.includes(key);
    const parts: string[] = [];
    parts.push(`type: '${cliType}'`);

    if (propSchema.description) {
      parts.push(`description: '${propSchema.description}'`);
    }

    parts.push(`required: ${isRequired}`);

    if (propSchema.enum) {
      const enumValues = (propSchema.enum as string[]).map((v) => `'${v}'`).join(', ');
      parts.push(`enum: [${enumValues}]`);
    }

    lines.push(`${indent}  ${key}: { ${parts.join(', ')} },`);
  }

  return lines;
}

export function emitCommandDefinition(op: CodegenOperation): string {
  const lines: string[] = [];
  lines.push('{');
  lines.push(`  method: '${op.method}',`);
  lines.push(`  path: '${op.path}',`);
  lines.push(`  description: '${op.description ?? op.operationId}',`);

  if (op.params) {
    const fields = emitFieldDefinitions(op.params, '  ');
    if (fields.length > 0) {
      lines.push('  params: {');
      lines.push(...fields);
      lines.push('  },');
    }
  }

  if (op.query) {
    const fields = emitFieldDefinitions(op.query, '  ');
    if (fields.length > 0) {
      lines.push('  query: {');
      lines.push(...fields);
      lines.push('  },');
    }
  }

  if (op.body) {
    const fields = emitFieldDefinitions(op.body, '  ');
    if (fields.length > 0) {
      lines.push('  body: {');
      lines.push(...fields);
      lines.push('  },');
    }
  }

  lines.push('}');
  return lines.join('\n');
}

export function emitModuleCommands(module: CodegenModule): string {
  if (module.operations.length === 0) {
    return '{}';
  }

  const entries: string[] = [];

  for (const op of module.operations) {
    const commandName = toKebabCase(op.operationId);
    const def = emitCommandDefinition(op);
    // Indent the definition body
    const indented = def
      .split('\n')
      .map((line, i) => (i === 0 ? line : `  ${line}`))
      .join('\n');
    entries.push(`  '${commandName}': ${indented},`);
  }

  return `{\n${entries.join('\n')}\n}`;
}

export function emitManifestFile(ir: CodegenIR): GeneratedFile {
  const sections: string[] = [FILE_HEADER];

  sections.push("import type { CommandManifest } from '@vertz/cli-runtime';");
  sections.push('');

  if (ir.modules.length === 0) {
    sections.push('export const commands: CommandManifest = {};');
  } else {
    const namespaceEntries: string[] = [];

    for (const mod of ir.modules) {
      const cmds = emitModuleCommands(mod);
      // Indent the commands block
      const indented = cmds
        .split('\n')
        .map((line, i) => (i === 0 ? line : `    ${line}`))
        .join('\n');
      namespaceEntries.push(`  ${mod.name}: ${indented},`);
    }

    sections.push(`export const commands: CommandManifest = {\n${namespaceEntries.join('\n')}\n};`);
  }

  return {
    path: 'cli/manifest.ts',
    content: sections.join('\n'),
  };
}

// ── Bin Entry Point ─────────────────────────────────────────────

export interface BinEntryPointOptions {
  cliName: string;
  cliVersion: string;
}

export function emitBinEntryPoint(options: BinEntryPointOptions): GeneratedFile {
  const lines: string[] = [];
  lines.push('#!/usr/bin/env node');
  lines.push(FILE_HEADER);
  lines.push("import { createCLI } from '@vertz/cli-runtime';");
  lines.push("import { commands } from './manifest';");
  lines.push('');
  lines.push('const cli = createCLI({');
  lines.push(`  name: '${options.cliName}',`);
  lines.push(`  version: '${options.cliVersion}',`);
  lines.push('  commands,');
  lines.push('});');
  lines.push('');
  lines.push('cli.run(process.argv.slice(2));');

  return {
    path: 'cli/bin.ts',
    content: lines.join('\n'),
  };
}

// ── Scaffold: CLI Package JSON ──────────────────────────────────

export interface CLIPackageOptions {
  packageName: string;
  packageVersion?: string;
  cliName: string;
}

export function scaffoldCLIPackageJson(options: CLIPackageOptions): GeneratedFile {
  const pkg = {
    name: options.packageName,
    version: options.packageVersion ?? '0.0.0',
    description: `CLI for ${options.cliName} — generated by @vertz/codegen`,
    private: true,
    bin: {
      [options.cliName]: './cli/bin.ts',
    },
    dependencies: {
      '@vertz/cli-runtime': '*',
      '@vertz/fetch': '*',
    },
  };

  return {
    path: 'package.json',
    content: JSON.stringify(pkg, null, 2),
  };
}

// ── Scaffold: Root Index ────────────────────────────────────────

export function scaffoldCLIRootIndex(): GeneratedFile {
  const lines: string[] = [FILE_HEADER];
  lines.push("export { commands } from './cli/manifest';");

  return {
    path: 'index.ts',
    content: lines.join('\n'),
  };
}
