const FILE_HEADER = '// Generated by @vertz/codegen — do not edit\n';
// ── JSON Schema → @vertz/schema call ────────────────────────────
function jsonSchemaToSchemaCall(schema) {
  const type = schema.type;
  if (type === 'string') return 's.string()';
  if (type === 'number') return 's.number()';
  if (type === 'integer') return 's.int()';
  if (type === 'boolean') return 's.boolean()';
  if (type === 'array') {
    const items = schema.items;
    if (items) {
      return `s.array(${jsonSchemaToSchemaCall(items)})`;
    }
    return 's.array(s.unknown())';
  }
  if (type === 'object') {
    const properties = schema.properties;
    if (!properties || Object.keys(properties).length === 0) {
      return 's.object({})';
    }
    const required = schema.required ?? [];
    const fields = Object.entries(properties).map(([key, propSchema]) => {
      const call = jsonSchemaToSchemaCall(propSchema);
      if (required.includes(key)) {
        return `  ${key}: ${call}`;
      }
      return `  ${key}: ${call}.optional()`;
    });
    return `s.object({\n${fields.join(',\n')},\n})`;
  }
  return 's.unknown()';
}
// ── emitSchemaReExports ─────────────────────────────────────────
export function emitSchemaReExports(schemas) {
  const sections = [FILE_HEADER];
  if (schemas.length > 0) {
    sections.push("import { s } from '@vertz/schema';");
    sections.push('');
  }
  for (const schema of schemas) {
    const validatorName = `${schema.name}Schema`;
    const schemaCall = jsonSchemaToSchemaCall(schema.jsonSchema);
    sections.push(`export const ${validatorName} = ${schemaCall};`);
  }
  return {
    path: 'schemas.ts',
    content: sections.join('\n'),
  };
}
export function emitBarrelIndex(ir) {
  const lines = [FILE_HEADER];
  // Client re-exports
  lines.push("export { createClient } from './client';");
  lines.push("export type { SDKConfig, SDKResult } from './client';");
  // Module type re-exports
  for (const mod of ir.modules) {
    lines.push(`export * from './types/${mod.name}';`);
  }
  // Shared types (only when schemas exist)
  if (ir.schemas.length > 0) {
    lines.push("export * from './types/shared';");
  }
  // Schema validators (only when schemas exist)
  if (ir.schemas.length > 0) {
    lines.push("export * from './schemas';");
  }
  return {
    path: 'index.ts',
    content: lines.join('\n'),
  };
}
// ── emitPackageJson ─────────────────────────────────────────────
export function emitPackageJson(ir, options) {
  const dependencies = {
    '@vertz/fetch': '*',
  };
  if (ir.schemas.length > 0) {
    dependencies['@vertz/schema'] = '*';
  }
  const pkg = {
    name: options.packageName,
    version: options.packageVersion ?? '0.0.0',
    description: 'Generated by @vertz/codegen',
    private: true,
    main: 'index.ts',
    types: 'index.ts',
    dependencies,
  };
  return {
    path: 'package.json',
    content: JSON.stringify(pkg, null, 2),
  };
}
//# sourceMappingURL=emit-sdk.js.map
