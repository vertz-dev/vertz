import type {
  CodegenAuth,
  CodegenIR,
  CodegenModule,
  CodegenOperation,
  FileFragment,
  GeneratedFile,
  Import,
} from '../../types';
import { mergeImports, renderImports } from '../../utils/imports';
import { toCamelCase, toPascalCase } from '../../utils/naming';

const FILE_HEADER = '// Generated by @vertz/codegen â€” do not edit\n';

export function emitSDKConfig(auth: CodegenAuth): FileFragment {
  const imports: Import[] = [{ from: '@vertz/fetch', name: 'FetchClientConfig', isType: true }];

  const fields: string[] = [];

  for (const scheme of auth.schemes) {
    if (scheme.type === 'bearer') {
      fields.push(
        '  /** Bearer token or function returning a token. */\n  token?: string | (() => string | Promise<string>);',
      );
    } else if (scheme.type === 'apiKey') {
      fields.push(
        '  /** API key or function returning a key. */\n  apiKey?: string | (() => string | Promise<string>);',
      );
    }
  }

  if (fields.length === 0) {
    return {
      content: 'export interface SDKConfig extends FetchClientConfig {}',
      imports,
    };
  }

  const content = `export interface SDKConfig extends FetchClientConfig {\n${fields.join('\n')}\n}`;
  return { content, imports };
}

export function emitAuthStrategyBuilder(auth: CodegenAuth): FileFragment {
  const imports: Import[] = [{ from: '@vertz/fetch', name: 'AuthStrategy', isType: true }];

  const lines: string[] = [];
  lines.push('const authStrategies: AuthStrategy[] = [...(config.authStrategies ?? [])];');

  for (const scheme of auth.schemes) {
    if (scheme.type === 'bearer') {
      lines.push(
        "if (config.token) {\n  authStrategies.push({ type: 'bearer', token: config.token });\n}",
      );
    } else if (scheme.type === 'apiKey') {
      lines.push(
        `if (config.apiKey) {\n  authStrategies.push({ type: 'apiKey', key: config.apiKey, location: '${scheme.in}', name: '${scheme.paramName}' });\n}`,
      );
    }
  }

  return { content: lines.join('\n'), imports };
}

function buildPathExpression(path: string): string {
  if (!path.includes(':')) {
    return `'${path}'`;
  }
  // biome-ignore lint/suspicious/noTemplateCurlyInString: replacement string for regex, not a template literal
  const interpolated = path.replace(/:([a-zA-Z_][a-zA-Z0-9_]*)/g, '${input.params.$1}');
  return `\`${interpolated}\``;
}

function buildRequestOptions(op: CodegenOperation): string {
  const opts: string[] = [];
  if (op.query) {
    opts.push('query: input?.query');
  }
  if (op.body) {
    opts.push('body: input.body');
  }
  if (op.headers) {
    opts.push('headers: input?.headers');
  }
  if (opts.length === 0) {
    return '';
  }
  return `, { ${opts.join(', ')} }`;
}

function hasOperationInput(op: CodegenOperation): boolean {
  return !!(op.params || op.query || op.body || op.headers);
}

function isInputOptional(op: CodegenOperation): boolean {
  return !op.params && !op.body;
}

export function emitOperationMethod(op: CodegenOperation): FileFragment {
  const imports: Import[] = [];
  const methodName = toCamelCase(op.operationId);
  const inputTypeName = `${toPascalCase(op.operationId)}Input`;
  const responseTypeName = `${toPascalCase(op.operationId)}Response`;

  const hasInput = hasOperationInput(op);

  if (hasInput) {
    const optional = isInputOptional(op);
    const inputParam = optional ? `input?: ${inputTypeName}` : `input: ${inputTypeName}`;
    imports.push({ from: '../types', name: inputTypeName, isType: true });
    imports.push({ from: '../types', name: responseTypeName, isType: true });

    const pathExpr = buildPathExpression(op.path);
    const reqOpts = buildRequestOptions(op);

    const content = `${methodName}(${inputParam}): Promise<SDKResult<${responseTypeName}>> {\n  return client.request('${op.method}', ${pathExpr}${reqOpts});\n}`;
    return { content, imports };
  }

  imports.push({ from: '../types', name: responseTypeName, isType: true });
  const pathExpr = buildPathExpression(op.path);
  const content = `${methodName}(): Promise<SDKResult<${responseTypeName}>> {\n  return client.request('${op.method}', ${pathExpr});\n}`;
  return { content, imports };
}

export function emitStreamingMethod(op: CodegenOperation): FileFragment {
  const imports: Import[] = [];
  const methodName = toCamelCase(op.operationId);
  const inputTypeName = `${toPascalCase(op.operationId)}Input`;
  const eventTypeName = `${toPascalCase(op.operationId)}Event`;
  const format = op.streaming?.format ?? 'sse';

  imports.push({ from: '../types', name: eventTypeName, isType: true });

  const hasInput = hasOperationInput(op);
  const pathExpr = buildPathExpression(op.path);

  const streamOpts: string[] = [];
  streamOpts.push(`method: '${op.method}'`);
  streamOpts.push(`path: ${pathExpr}`);
  if (op.query) {
    streamOpts.push('query: input?.query');
  }
  streamOpts.push(`format: '${format}'`);

  const optsStr = streamOpts.join(',\n    ');

  if (hasInput) {
    const optional = isInputOptional(op);
    const inputParam = optional ? `input?: ${inputTypeName}` : `input: ${inputTypeName}`;
    imports.push({ from: '../types', name: inputTypeName, isType: true });

    const content = `async *${methodName}(${inputParam}): AsyncGenerator<${eventTypeName}> {\n  yield* client.requestStream<${eventTypeName}>({\n    ${optsStr},\n  });\n}`;
    return { content, imports };
  }

  const content = `async *${methodName}(): AsyncGenerator<${eventTypeName}> {\n  yield* client.requestStream<${eventTypeName}>({\n    ${optsStr},\n  });\n}`;
  return { content, imports };
}

export function emitModuleFile(module: CodegenModule): GeneratedFile {
  const fragments: FileFragment[] = [];

  for (const op of module.operations) {
    if (op.streaming) {
      fragments.push(emitStreamingMethod(op));
    } else {
      fragments.push(emitOperationMethod(op));
    }
  }

  const allImports = mergeImports(fragments.flatMap((f) => f.imports));
  const importBlock = renderImports(allImports);

  const factoryName = `create${toPascalCase(module.name)}Module`;
  const methods = fragments.map((f) => `    ${f.content}`).join(',\n');

  const sections: string[] = [FILE_HEADER];
  if (importBlock) {
    sections.push(importBlock);
    sections.push('');
  }

  sections.push(
    `export function ${factoryName}(client: FetchClient) {\n  return {\n${methods},\n  };\n}`,
  );

  const fetchClientImport = "import { FetchClient } from '@vertz/fetch';";

  // Insert FetchClient import after the header
  const content = sections.join('\n');
  const withFetchImport = content.replace(FILE_HEADER, `${FILE_HEADER}\n${fetchClientImport}\n`);

  return {
    path: `modules/${module.name}.ts`,
    content: withFetchImport,
  };
}

export function emitClientFile(ir: CodegenIR): GeneratedFile {
  const sections: string[] = [FILE_HEADER];
  const imports: Import[] = [];

  // Import FetchClient
  imports.push({ from: '@vertz/fetch', name: 'FetchClient', isType: false });

  // SDKConfig fragment
  const configFragment = emitSDKConfig(ir.auth);
  imports.push(...configFragment.imports);

  // Auth strategy builder
  const authFragment = emitAuthStrategyBuilder(ir.auth);
  imports.push(...authFragment.imports);

  // Module imports
  for (const mod of ir.modules) {
    const factoryName = `create${toPascalCase(mod.name)}Module`;
    imports.push({ from: `./modules/${mod.name}`, name: factoryName, isType: false });
  }

  const allImports = mergeImports(imports);
  const importBlock = renderImports(allImports);
  if (importBlock) {
    sections.push(importBlock);
    sections.push('');
  }

  // SDKResult type
  sections.push(
    'export interface SDKResult<T> {\n  data: T;\n  status: number;\n  headers: Headers;\n}',
  );
  sections.push('');

  // SDKConfig interface
  sections.push(configFragment.content);
  sections.push('');

  // createClient function
  const moduleEntries = ir.modules
    .map((mod) => `    ${toCamelCase(mod.name)}: create${toPascalCase(mod.name)}Module(client)`)
    .join(',\n');

  const createClientBody = [
    'export function createClient(config: SDKConfig) {',
    `  ${authFragment.content.split('\n').join('\n  ')}`,
    '',
    '  const client = new FetchClient({',
    '    ...config,',
    '    authStrategies,',
    '  });',
    '',
    '  return {',
    moduleEntries,
    '  };',
    '}',
  ].join('\n');

  sections.push(createClientBody);

  return {
    path: 'client.ts',
    content: sections.join('\n'),
  };
}
