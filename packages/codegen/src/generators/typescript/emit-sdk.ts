import type { CodegenIR, CodegenSchema, GeneratedFile } from '../../types';

const FILE_HEADER = '// Generated by @vertz/codegen — do not edit\n';

// ── JSON Schema → @vertz/schema call ────────────────────────────

function jsonSchemaToSchemaCall(schema: Record<string, unknown>): string {
  const type = schema.type as string | undefined;

  if (type === 'string') return 's.string()';
  if (type === 'number') return 's.number()';
  if (type === 'integer') return 's.int()';
  if (type === 'boolean') return 's.boolean()';

  if (type === 'array') {
    const items = schema.items as Record<string, unknown> | undefined;
    if (items) {
      return `s.array(${jsonSchemaToSchemaCall(items)})`;
    }
    return 's.array(s.unknown())';
  }

  if (type === 'object') {
    const properties = schema.properties as Record<string, Record<string, unknown>> | undefined;
    if (!properties || Object.keys(properties).length === 0) {
      return 's.object({})';
    }

    const required = (schema.required as string[]) ?? [];
    const fields = Object.entries(properties).map(([key, propSchema]) => {
      const call = jsonSchemaToSchemaCall(propSchema);
      if (required.includes(key)) {
        return `  ${key}: ${call}`;
      }
      return `  ${key}: ${call}.optional()`;
    });

    return `s.object({\n${fields.join(',\n')},\n})`;
  }

  return 's.unknown()';
}

// ── emitSchemaReExports ─────────────────────────────────────────

export function emitSchemaReExports(schemas: CodegenSchema[]): GeneratedFile {
  const sections: string[] = [FILE_HEADER];

  if (schemas.length > 0) {
    sections.push("import { s } from '@vertz/schema';");
    sections.push('');
  }

  for (const schema of schemas) {
    const validatorName = `${schema.name}Schema`;
    const schemaCall = jsonSchemaToSchemaCall(schema.jsonSchema);
    sections.push(`export const ${validatorName} = ${schemaCall};`);
  }

  return {
    path: 'schemas.ts',
    content: sections.join('\n'),
  };
}

// ── emitBarrelIndex ─────────────────────────────────────────────

export interface PackageOptions {
  packageName: string;
  packageVersion?: string;
}

export function emitBarrelIndex(ir: CodegenIR): GeneratedFile {
  const lines: string[] = [FILE_HEADER];

  // Client re-exports
  lines.push("export { createClient } from './client';");
  lines.push("export type { SDKConfig } from './client';");
  lines.push("export type { Result, FetchError } from '@vertz/errors';");

  // Module type re-exports
  for (const mod of ir.modules) {
    lines.push(`export * from './types/${mod.name}';`);
  }

  // Shared types (only when schemas exist)
  if (ir.schemas.length > 0) {
    lines.push("export * from './types/shared';");
  }

  // Schema validators (only when schemas exist)
  if (ir.schemas.length > 0) {
    lines.push("export * from './schemas';");
  }

  return {
    path: 'index.ts',
    content: lines.join('\n'),
  };
}

// ── emitPackageJson ─────────────────────────────────────────────

export function emitPackageJson(ir: CodegenIR, options: PackageOptions): GeneratedFile {
  const dependencies: Record<string, string> = {
    '@vertz/errors': '*',
    '@vertz/fetch': '*',
  };

  if (ir.schemas.length > 0) {
    dependencies['@vertz/schema'] = '*';
  }

  const pkg = {
    name: options.packageName,
    version: options.packageVersion ?? '0.0.0',
    description: 'Generated by @vertz/codegen',
    private: true,
    main: 'index.ts',
    types: 'index.ts',
    dependencies,
  };

  return {
    path: 'package.json',
    content: JSON.stringify(pkg, null, 2),
  };
}
