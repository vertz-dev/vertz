import { describe, expect, it } from 'vitest';
import {
  emitBarrelIndex,
  emitPackageJson,
  emitSchemaReExports,
} from '../../generators/typescript/emit-sdk';
import type {
  CodegenAuth,
  CodegenIR,
  CodegenModule,
  CodegenOperation,
  CodegenSchema,
} from '../../types';

// ── Fixture helpers ──────────────────────────────────────────────

function makeSchema(overrides: Partial<CodegenSchema>): CodegenSchema {
  return {
    name: 'TestSchema',
    jsonSchema: { type: 'object' },
    annotations: { namingParts: {} },
    ...overrides,
  };
}

function makeOp(overrides: Partial<CodegenOperation>): CodegenOperation {
  return {
    operationId: 'test',
    method: 'GET',
    path: '/test',
    tags: [],
    schemaRefs: {},
    ...overrides,
  };
}

function makeModule(overrides: Partial<CodegenModule>): CodegenModule {
  return {
    name: 'test',
    operations: [],
    ...overrides,
  };
}

function makeAuth(overrides: Partial<CodegenAuth>): CodegenAuth {
  return {
    schemes: [],
    ...overrides,
  };
}

function makeIR(overrides: Partial<CodegenIR>): CodegenIR {
  return {
    basePath: '/api/v1',
    modules: [],
    schemas: [],
    auth: makeAuth({}),
    ...overrides,
  };
}

// ── emitSchemaReExports ──────────────────────────────────────────

describe('emitSchemaReExports', () => {
  it('generates a schemas.ts file with schema validator re-exports for each named schema', () => {
    const schemas = [
      makeSchema({
        name: 'User',
        jsonSchema: {
          type: 'object',
          properties: { name: { type: 'string' }, age: { type: 'number' } },
          required: ['name'],
        },
      }),
    ];

    const result = emitSchemaReExports(schemas);

    expect(result.path).toBe('schemas.ts');
    expect(result.content).toContain('// Generated by @vertz/codegen');
    expect(result.content).toContain('UserSchema');
    expect(result.content).toContain("from '@vertz/schema'");
  });

  it('generates s.object() with property calls matching JSON schema types', () => {
    const schemas = [
      makeSchema({
        name: 'User',
        jsonSchema: {
          type: 'object',
          properties: { name: { type: 'string' }, age: { type: 'number' } },
          required: ['name'],
        },
      }),
    ];

    const result = emitSchemaReExports(schemas);

    expect(result.content).toContain('s.object(');
    expect(result.content).toContain('name: s.string()');
    expect(result.content).toContain('age: s.number().optional()');
  });

  it('generates multiple schema exports for multiple schemas', () => {
    const schemas = [
      makeSchema({ name: 'User', jsonSchema: { type: 'object' } }),
      makeSchema({ name: 'Post', jsonSchema: { type: 'object' } }),
      makeSchema({ name: 'Comment', jsonSchema: { type: 'object' } }),
    ];

    const result = emitSchemaReExports(schemas);

    expect(result.content).toContain('export const UserSchema');
    expect(result.content).toContain('export const PostSchema');
    expect(result.content).toContain('export const CommentSchema');
  });

  it('handles string schemas', () => {
    const schemas = [makeSchema({ name: 'Name', jsonSchema: { type: 'string' } })];
    const result = emitSchemaReExports(schemas);
    expect(result.content).toContain('export const NameSchema = s.string()');
  });

  it('handles number schemas', () => {
    const schemas = [makeSchema({ name: 'Age', jsonSchema: { type: 'number' } })];
    const result = emitSchemaReExports(schemas);
    expect(result.content).toContain('export const AgeSchema = s.number()');
  });

  it('handles integer schemas as s.int()', () => {
    const schemas = [makeSchema({ name: 'Count', jsonSchema: { type: 'integer' } })];
    const result = emitSchemaReExports(schemas);
    expect(result.content).toContain('export const CountSchema = s.int()');
  });

  it('handles boolean schemas', () => {
    const schemas = [makeSchema({ name: 'Active', jsonSchema: { type: 'boolean' } })];
    const result = emitSchemaReExports(schemas);
    expect(result.content).toContain('export const ActiveSchema = s.boolean()');
  });

  it('handles array schemas with typed items', () => {
    const schemas = [
      makeSchema({
        name: 'Tags',
        jsonSchema: { type: 'array', items: { type: 'string' } },
      }),
    ];
    const result = emitSchemaReExports(schemas);
    expect(result.content).toContain('export const TagsSchema = s.array(s.string())');
  });

  it('handles array schemas without items as s.array(s.unknown())', () => {
    const schemas = [makeSchema({ name: 'Items', jsonSchema: { type: 'array' } })];
    const result = emitSchemaReExports(schemas);
    expect(result.content).toContain('export const ItemsSchema = s.array(s.unknown())');
  });

  it('handles unknown/missing type as s.unknown()', () => {
    const schemas = [makeSchema({ name: 'Anything', jsonSchema: {} })];
    const result = emitSchemaReExports(schemas);
    expect(result.content).toContain('export const AnythingSchema = s.unknown()');
  });

  it('generates empty schemas file with only header when no schemas are provided', () => {
    const result = emitSchemaReExports([]);

    expect(result.path).toBe('schemas.ts');
    expect(result.content).toContain('// Generated by @vertz/codegen');
    expect(result.content).not.toContain("from '@vertz/schema'");
  });

  it('marks required properties without .optional() and optional properties with .optional()', () => {
    const schemas = [
      makeSchema({
        name: 'Config',
        jsonSchema: {
          type: 'object',
          properties: {
            host: { type: 'string' },
            port: { type: 'number' },
            debug: { type: 'boolean' },
          },
          required: ['host', 'port'],
        },
      }),
    ];

    const result = emitSchemaReExports(schemas);

    expect(result.content).toContain('host: s.string()');
    expect(result.content).toContain('port: s.number()');
    expect(result.content).toContain('debug: s.boolean().optional()');
    // Ensure required fields do NOT have .optional()
    expect(result.content).not.toContain('host: s.string().optional()');
    expect(result.content).not.toContain('port: s.number().optional()');
  });

  it('handles nested object schemas', () => {
    const schemas = [
      makeSchema({
        name: 'UserProfile',
        jsonSchema: {
          type: 'object',
          properties: {
            address: {
              type: 'object',
              properties: {
                street: { type: 'string' },
                city: { type: 'string' },
              },
              required: ['street'],
            },
          },
          required: ['address'],
        },
      }),
    ];

    const result = emitSchemaReExports(schemas);

    expect(result.content).toContain('address: s.object(');
    expect(result.content).toContain('street: s.string()');
    expect(result.content).toContain('city: s.string().optional()');
  });
});

// ── emitBarrelIndex ─────────────────────────────────────────────

describe('emitBarrelIndex', () => {
  it('generates an index.ts barrel file', () => {
    const result = emitBarrelIndex(makeIR({}));

    expect(result.path).toBe('index.ts');
    expect(result.content).toContain('// Generated by @vertz/codegen');
  });

  it('re-exports from client.ts', () => {
    const result = emitBarrelIndex(makeIR({}));

    expect(result.content).toContain("export { createClient } from './client';");
    expect(result.content).toContain("export type { SDKConfig } from './client';");
    expect(result.content).toContain("export type { Result, FetchError } from '@vertz/errors';");
  });

  it('re-exports module types from the types directory for each module', () => {
    const result = emitBarrelIndex(
      makeIR({
        modules: [
          makeModule({ name: 'users', operations: [] }),
          makeModule({ name: 'billing', operations: [] }),
        ],
      }),
    );

    expect(result.content).toContain("export * from './types/users';");
    expect(result.content).toContain("export * from './types/billing';");
  });

  it('re-exports shared types when there are global schemas', () => {
    const result = emitBarrelIndex(
      makeIR({
        schemas: [makeSchema({ name: 'User' })],
      }),
    );

    expect(result.content).toContain("export * from './types/shared';");
  });

  it('does not re-export shared types when there are no schemas', () => {
    const result = emitBarrelIndex(makeIR({ schemas: [] }));

    expect(result.content).not.toContain("export * from './types/shared';");
  });

  it('re-exports from schemas.ts when there are schemas', () => {
    const result = emitBarrelIndex(
      makeIR({
        schemas: [makeSchema({ name: 'User' })],
      }),
    );

    expect(result.content).toContain("export * from './schemas';");
  });

  it('does not re-export schemas when there are no schemas', () => {
    const result = emitBarrelIndex(makeIR({ schemas: [] }));

    expect(result.content).not.toContain("export * from './schemas';");
  });

  it('generates correct order: client, types, schemas', () => {
    const result = emitBarrelIndex(
      makeIR({
        modules: [makeModule({ name: 'users', operations: [] })],
        schemas: [makeSchema({ name: 'User' })],
      }),
    );

    const clientIdx = result.content.indexOf("from './client'");
    const typesIdx = result.content.indexOf("from './types/users'");
    const schemasIdx = result.content.indexOf("from './schemas'");

    expect(clientIdx).toBeLessThan(typesIdx);
    expect(typesIdx).toBeLessThan(schemasIdx);
  });

  it('generates a complete index for an IR with no modules and no schemas', () => {
    const result = emitBarrelIndex(makeIR({ modules: [], schemas: [] }));

    expect(result.content).toContain("export { createClient } from './client';");
    expect(result.content).toContain("export type { SDKConfig } from './client';");
    expect(result.content).toContain("export type { Result, FetchError } from '@vertz/errors';");
    expect(result.content).not.toContain('./types/');
    expect(result.content).not.toContain('./schemas');
  });
});

// ── emitPackageJson ─────────────────────────────────────────────

describe('emitPackageJson', () => {
  it('generates a package.json file', () => {
    const result = emitPackageJson(makeIR({}), { packageName: '@acme/sdk' });

    expect(result.path).toBe('package.json');
  });

  it('uses the provided package name', () => {
    const result = emitPackageJson(makeIR({}), { packageName: '@acme/sdk' });
    const pkg = JSON.parse(result.content);

    expect(pkg.name).toBe('@acme/sdk');
  });

  it('uses the provided version', () => {
    const result = emitPackageJson(makeIR({ version: '2.3.0' }), {
      packageName: '@acme/sdk',
      packageVersion: '2.3.0',
    });
    const pkg = JSON.parse(result.content);

    expect(pkg.version).toBe('2.3.0');
  });

  it('defaults version to 0.0.0 when not provided', () => {
    const result = emitPackageJson(makeIR({}), { packageName: '@acme/sdk' });
    const pkg = JSON.parse(result.content);

    expect(pkg.version).toBe('0.0.0');
  });

  it('lists @vertz/fetch as a dependency', () => {
    const result = emitPackageJson(makeIR({}), { packageName: '@acme/sdk' });
    const pkg = JSON.parse(result.content);

    expect(pkg.dependencies).toHaveProperty('@vertz/fetch');
  });

  it('lists @vertz/errors as a dependency', () => {
    const result = emitPackageJson(makeIR({}), { packageName: '@acme/sdk' });
    const pkg = JSON.parse(result.content);

    expect(pkg.dependencies).toHaveProperty('@vertz/errors');
  });

  it('lists @vertz/schema as a dependency when schemas exist', () => {
    const result = emitPackageJson(makeIR({ schemas: [makeSchema({ name: 'User' })] }), {
      packageName: '@acme/sdk',
    });
    const pkg = JSON.parse(result.content);

    expect(pkg.dependencies).toHaveProperty('@vertz/schema');
  });

  it('does not list @vertz/schema as a dependency when there are no schemas', () => {
    const result = emitPackageJson(makeIR({ schemas: [] }), { packageName: '@acme/sdk' });
    const pkg = JSON.parse(result.content);

    expect(pkg.dependencies).not.toHaveProperty('@vertz/schema');
  });

  it('sets main entry point to index.ts', () => {
    const result = emitPackageJson(makeIR({}), { packageName: '@acme/sdk' });
    const pkg = JSON.parse(result.content);

    expect(pkg.main).toBe('index.ts');
  });

  it('sets types entry point to index.ts', () => {
    const result = emitPackageJson(makeIR({}), { packageName: '@acme/sdk' });
    const pkg = JSON.parse(result.content);

    expect(pkg.types).toBe('index.ts');
  });

  it('marks the package as private by default', () => {
    const result = emitPackageJson(makeIR({}), { packageName: '@acme/sdk' });
    const pkg = JSON.parse(result.content);

    expect(pkg.private).toBe(true);
  });

  it('generates valid JSON', () => {
    const result = emitPackageJson(
      makeIR({
        schemas: [makeSchema({ name: 'User' })],
        modules: [makeModule({ name: 'users' })],
      }),
      { packageName: '@acme/api-sdk', packageVersion: '1.0.0' },
    );

    expect(() => JSON.parse(result.content)).not.toThrow();
  });

  it('includes a description field', () => {
    const result = emitPackageJson(makeIR({}), { packageName: '@acme/sdk' });
    const pkg = JSON.parse(result.content);

    expect(pkg.description).toContain('Generated');
  });
});

// ── Integration: full IR to generated SDK package ────────────────

describe('integration', () => {
  it('generates all SDK package files for a complete IR', () => {
    const ir = makeIR({
      auth: makeAuth({
        schemes: [{ type: 'bearer', name: 'bearerAuth' }],
      }),
      modules: [
        makeModule({
          name: 'users',
          operations: [
            makeOp({
              operationId: 'listUsers',
              method: 'GET',
              path: '/api/v1/users',
              query: { type: 'object', properties: { page: { type: 'number' } } },
            }),
          ],
        }),
      ],
      schemas: [
        makeSchema({
          name: 'User',
          jsonSchema: {
            type: 'object',
            properties: { name: { type: 'string' }, email: { type: 'string' } },
            required: ['name', 'email'],
          },
        }),
      ],
    });

    // Schema re-exports
    const schemasFile = emitSchemaReExports(ir.schemas);
    expect(schemasFile.path).toBe('schemas.ts');
    expect(schemasFile.content).toContain('UserSchema');
    expect(schemasFile.content).toContain('s.object(');

    // Barrel index
    const indexFile = emitBarrelIndex(ir);
    expect(indexFile.path).toBe('index.ts');
    expect(indexFile.content).toContain("export { createClient } from './client'");
    expect(indexFile.content).toContain("export * from './types/users'");
    expect(indexFile.content).toContain("export * from './types/shared'");
    expect(indexFile.content).toContain("export * from './schemas'");

    // Package JSON
    const pkgFile = emitPackageJson(ir, { packageName: '@acme/api-sdk', packageVersion: '1.0.0' });
    expect(pkgFile.path).toBe('package.json');
    const pkg = JSON.parse(pkgFile.content);
    expect(pkg.name).toBe('@acme/api-sdk');
    expect(pkg.version).toBe('1.0.0');
    expect(pkg.dependencies).toHaveProperty('@vertz/fetch');
    expect(pkg.dependencies).toHaveProperty('@vertz/schema');
  });
});
