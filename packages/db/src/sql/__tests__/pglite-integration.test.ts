import { PGlite } from '@electric-sql/pglite';
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import { buildDelete } from '../delete';
import { buildInsert } from '../insert';
import { buildSelect } from '../select';
import { buildUpdate } from '../update';
import { buildWhere } from '../where';

/**
 * PGlite integration tests â€” DB-008 acceptance criteria.
 *
 * These tests verify that SQL generated by the builders executes
 * correctly against a real PostgreSQL engine (PGlite / in-process).
 */
describe('PGlite integration: generated SQL executes', () => {
  let db: PGlite;

  beforeAll(async () => {
    db = new PGlite();
    await db.exec(`
      CREATE TABLE users (
        id SERIAL PRIMARY KEY,
        first_name TEXT NOT NULL,
        last_name TEXT NOT NULL,
        email TEXT UNIQUE NOT NULL,
        age INTEGER,
        active BOOLEAN DEFAULT TRUE,
        tags TEXT[] DEFAULT '{}',
        metadata JSONB DEFAULT '{}'
      );
    `);
  });

  afterAll(async () => {
    await db.close();
  });

  it('INSERT executes and returns rows', async () => {
    const result = buildInsert({
      table: 'users',
      data: {
        firstName: 'Alice',
        lastName: 'Smith',
        email: 'alice@example.com',
        age: 30,
      },
      returning: ['id', 'firstName', 'email'],
    });
    const rows = await db.query(result.sql, result.params as unknown[]);
    expect(rows.rows).toHaveLength(1);
    expect(rows.rows[0]).toHaveProperty('id');
    expect(rows.rows[0]).toHaveProperty('firstName', 'Alice');
  });

  it('SELECT with WHERE executes', async () => {
    const result = buildSelect({
      table: 'users',
      where: { firstName: 'Alice' },
    });
    const rows = await db.query(result.sql, result.params as unknown[]);
    expect(rows.rows).toHaveLength(1);
  });

  it('SELECT with LIKE (contains) executes correctly', async () => {
    const result = buildSelect({
      table: 'users',
      where: { firstName: { contains: 'lic' } },
    });
    const rows = await db.query(result.sql, result.params as unknown[]);
    expect(rows.rows).toHaveLength(1);
  });

  it('SELECT with parameterized LIMIT/OFFSET executes', async () => {
    const result = buildSelect({
      table: 'users',
      limit: 10,
      offset: 0,
    });
    const rows = await db.query(result.sql, result.params as unknown[]);
    expect(rows.rows).toHaveLength(1);
  });

  it('SELECT with empty IN produces valid SQL', async () => {
    const where = buildWhere({ firstName: { in: [] } });
    // Empty IN should produce FALSE, so no rows
    const sql = `SELECT * FROM users WHERE ${where.sql}`;
    const rows = await db.query(sql, where.params as unknown[]);
    expect(rows.rows).toHaveLength(0);
  });

  it('UPDATE executes and returns affected rows', async () => {
    const result = buildUpdate({
      table: 'users',
      data: { age: 31 },
      where: { firstName: 'Alice' },
      returning: ['id', 'age'],
    });
    const rows = await db.query(result.sql, result.params as unknown[]);
    expect(rows.rows).toHaveLength(1);
    expect(rows.rows[0]).toHaveProperty('age', 31);
  });

  it('SELECT with ORDER BY and LIMIT executes', async () => {
    // Insert a second user first
    const ins = buildInsert({
      table: 'users',
      data: {
        firstName: 'Bob',
        lastName: 'Jones',
        email: 'bob@example.com',
        age: 25,
      },
      returning: ['id'],
    });
    await db.query(ins.sql, ins.params as unknown[]);

    const result = buildSelect({
      table: 'users',
      orderBy: { age: 'asc' },
      limit: 1,
    });
    const rows = await db.query(result.sql, result.params as unknown[]);
    expect(rows.rows).toHaveLength(1);
    expect(rows.rows[0]).toHaveProperty('first_name', 'Bob');
  });

  it('DELETE executes and returns deleted rows', async () => {
    const result = buildDelete({
      table: 'users',
      where: { firstName: 'Bob' },
      returning: ['id'],
    });
    const rows = await db.query(result.sql, result.params as unknown[]);
    expect(rows.rows).toHaveLength(1);
  });

  it('SELECT with COUNT(*) OVER() executes', async () => {
    const result = buildSelect({
      table: 'users',
      withCount: true,
    });
    const rows = await db.query(result.sql, result.params as unknown[]);
    expect(rows.rows).toHaveLength(1);
    expect(rows.rows[0]).toHaveProperty('totalCount');
  });
});
