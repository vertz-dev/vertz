/**
 * ThemeProvider — Sets `data-theme` attribute for contextual token switching.
 *
 * Creates a wrapper div element with the appropriate `data-theme` attribute
 * so that contextual CSS custom properties (generated by compileTheme) resolve
 * to the correct variant values.
 *
 * Usage:
 * ```ts
 * ThemeProvider({ theme: 'dark', children: [myApp] });
 * ```
 */

/** A child node: either a DOM Node or a string (text content). */
export type ThemeChild = Node | string;

/** Props for ThemeProvider. */
export interface ThemeProviderProps {
  /** The theme variant name (e.g., 'light', 'dark'). Defaults to 'light'. */
  theme?: string;
  /** Child elements to render inside the provider. */
  children: ThemeChild[];
}

/**
 * Create a wrapper div with `data-theme` attribute for theme switching.
 *
 * During SSR (when `document` is unavailable), returns a VNode-compatible
 * plain object so the server renderer can serialize it.
 *
 * @param props - Theme and children.
 * @returns A div element (client) or VNode-compatible object (SSR).
 */
export function ThemeProvider(props: ThemeProviderProps): HTMLDivElement | unknown {
  const { theme = 'light', children } = props;

  // SSR: return a VNode-compatible structure for the server renderer.
  // VNode uses `attrs` (not props) — see @vertz/ui-server/types.ts
  // NOTE: "no document" alone doesn't mean SSR (TUI has no document).
  // Check positive SSR indicators + document absence together.
  let ssr = false;
  try { ssr = !!(import.meta as any).env?.SSR; } catch { /* ignore */ }
  if (!ssr && typeof globalThis !== 'undefined') {
    ssr = (globalThis as any).__SSR_URL__ !== undefined;
  }
  if (!ssr && typeof document === 'undefined') ssr = true;
  if (ssr) {
    return {
      tag: 'div',
      attrs: { 'data-theme': theme },
      children,
    };
  }

  const el = document.createElement('div');
  el.setAttribute('data-theme', theme);

  for (const child of children) {
    if (typeof child === 'string') {
      el.appendChild(document.createTextNode(child));
    } else {
      el.appendChild(child);
    }
  }

  return el;
}
