import type { Result } from '@vertz/fetch';
import { computed, signal } from '../runtime/signal';
import type { ReadonlySignal, Signal } from '../runtime/signal-types';
import { createFieldState, type FieldState } from './field-state';
import { formDataToObject } from './form-data';
import type { FormSchema } from './validation';
import { validate } from './validation';

/**
 * An SDK method with endpoint metadata attached.
 * Generated SDK methods expose `.url` and `.method` for progressive enhancement.
 */
export interface SdkMethod<TBody, TResult> {
  (body: TBody): PromiseLike<Result<TResult, Error>>;
  url: string;
  method: string;
  meta?: { bodySchema?: FormSchema<TBody> };
}

/**
 * An SDK method with embedded schema metadata.
 * Generated by `@vertz/codegen` — carries `.meta.bodySchema` for auto-validation.
 */
export interface SdkMethodWithMeta<TBody, TResult> extends SdkMethod<TBody, TResult> {
  meta: { bodySchema: FormSchema<TBody> };
}

/** Reserved property names that cannot be used as field names on FormInstance. */
export type ReservedFormNames =
  | 'submitting'
  | 'dirty'
  | 'valid'
  | 'action'
  | 'method'
  | 'onSubmit'
  | 'reset'
  | 'setFieldError'
  | 'submit'
  | '__bindElement';

export type { FieldState };

/** Mapped type providing FieldState for each field in TBody. */
export type FieldAccessors<TBody> = { [K in keyof TBody]: FieldState<TBody[K]> };

/** Base properties available on every form instance. */
export interface FormBaseProperties<TBody> {
  action: string;
  method: string;
  onSubmit: (e: Event) => Promise<void>;
  reset: () => void;
  setFieldError: (field: keyof TBody & string, message: string) => void;
  submit: (formData?: FormData) => Promise<void>;
  submitting: Signal<boolean>;
  dirty: ReadonlySignal<boolean>;
  valid: ReadonlySignal<boolean>;
  __bindElement: (el: HTMLFormElement) => void;
}

/**
 * A form instance bound to an SDK method.
 * Combines base properties with per-field reactive state via Proxy.
 * If TBody has any key that conflicts with ReservedFormNames, it produces a type error.
 * TResult is used by form() overloads for return type inference.
 */
export type FormInstance<TBody, _TResult> = keyof TBody & ReservedFormNames extends never
  ? FormBaseProperties<TBody> & FieldAccessors<TBody>
  : {
      __error: `Field name conflicts with reserved form property: ${keyof TBody & ReservedFormNames & string}`;
    };

/** Options for creating a form instance. */
export interface FormOptions<TBody, TResult> {
  /** Explicit schema for client-side validation before submission. */
  schema?: FormSchema<TBody>;
  /** Initial values for form fields. */
  initial?: Partial<TBody>;
  /** Callback invoked after a successful submission. */
  onSuccess?: (result: TResult) => void;
  /** Callback invoked when validation or submission fails. */
  onError?: (errors: Record<string, string>) => void;
  /** When true, reset the form after a successful submission. */
  resetOnSuccess?: boolean;
}

/**
 * Create a form instance bound to an SDK method.
 *
 * The form provides direct properties for progressive enhancement (action, method, onSubmit),
 * per-field reactive state via Proxy, and submission handling with validation.
 *
 * When the SDK method has `.meta.bodySchema` (generated by `@vertz/codegen`),
 * the schema option is optional. When the SDK method lacks `.meta`, the schema option is required.
 */
export function form<TBody, TResult>(
  sdkMethod: SdkMethodWithMeta<TBody, TResult>,
  options?: FormOptions<TBody, TResult>,
): FormInstance<TBody, TResult>;
export function form<TBody, TResult>(
  sdkMethod: SdkMethod<TBody, TResult>,
  options: Required<Pick<FormOptions<TBody, TResult>, 'schema'>> & FormOptions<TBody, TResult>,
): FormInstance<TBody, TResult>;
export function form<TBody, TResult>(
  sdkMethod: SdkMethod<TBody, TResult>,
  options?: FormOptions<TBody, TResult>,
): FormInstance<TBody, TResult> {
  const fieldCache = new Map<string, FieldState>();
  const submitting = signal(false);
  // Generation counter — incremented when new fields are added to the cache.
  // Computed signals read this to re-evaluate when the field set changes.
  const fieldGeneration = signal(0);

  const dirty = computed(() => {
    fieldGeneration.value; // subscribe to field additions
    for (const field of fieldCache.values()) {
      if (field.dirty.value) return true;
    }
    return false;
  });

  const valid = computed(() => {
    fieldGeneration.value; // subscribe to field additions
    for (const field of fieldCache.values()) {
      if (field.error.value !== undefined) return false;
    }
    return true;
  });

  function getOrCreateField(name: string): FieldState {
    let field = fieldCache.get(name);
    if (!field) {
      const initialValue = (options?.initial as Record<string, unknown> | undefined)?.[name];
      field = createFieldState(name, initialValue);
      fieldCache.set(name, field);
      fieldGeneration.value++;
    }
    return field;
  }

  const resolvedSchema = options?.schema ?? sdkMethod.meta?.bodySchema;

  async function submitPipeline(formData: FormData): Promise<void> {
    const data = formDataToObject(formData);

    if (resolvedSchema) {
      const result = validate(resolvedSchema, data);
      if (!result.success) {
        for (const [fieldName, message] of Object.entries(result.errors)) {
          getOrCreateField(fieldName).error.value = message;
        }
        options?.onError?.(result.errors);
        return;
      }
    }

    // Clear previous errors
    for (const field of fieldCache.values()) {
      field.error.value = undefined;
    }

    submitting.value = true;
    const result = await sdkMethod(data as TBody);
    if (!result.ok) {
      submitting.value = false;
      const message = result.error.message;
      getOrCreateField('_form').error.value = message;
      options?.onError?.({ _form: message });
      return;
    }
    submitting.value = false;
    options?.onSuccess?.(result.data);

    if (options?.resetOnSuccess) {
      resetForm();
    }
  }

  let boundElement: HTMLFormElement | undefined;

  function resetForm(): void {
    for (const field of fieldCache.values()) {
      field.reset();
    }
  }

  async function submitPipelineWithReset(formData: FormData): Promise<void> {
    await submitPipeline(formData);
    if (options?.resetOnSuccess && !submitting.peek() && boundElement) {
      // Only call reset on the element if submission succeeded (submitting is already false
      // and no error was set). Check that there are no errors as a proxy for success.
      const hasErrors = [...fieldCache.values()].some((f) => f.error.peek() !== undefined);
      if (!hasErrors) {
        boundElement.reset();
      }
    }
  }

  function handleInputOrChange(e: Event): void {
    const target = e.target as HTMLInputElement | null;
    if (!target?.name) return;
    const field = getOrCreateField(target.name);
    field.setValue(target.value);
  }

  function handleFocusout(e: Event): void {
    const target = e.target as HTMLInputElement | null;
    if (!target?.name) return;
    const field = getOrCreateField(target.name);
    field.touched.value = true;
  }

  const baseProperties: Record<string, unknown> = {
    action: sdkMethod.url,
    method: sdkMethod.method,
    onSubmit: async (e: Event) => {
      e.preventDefault();
      const formElement = e.target as HTMLFormElement;
      const formData = new FormData(formElement);
      await submitPipeline(formData);
      if (options?.resetOnSuccess && !submitting.peek()) {
        const hasErrors = [...fieldCache.values()].some((f) => f.error.peek() !== undefined);
        if (!hasErrors) {
          formElement.reset();
        }
      }
    },
    reset: resetForm,
    setFieldError: (field: string, message: string) => {
      getOrCreateField(field).error.value = message;
    },
    submit: async (formData?: FormData) => {
      if (formData) {
        await submitPipeline(formData);
      } else if (boundElement) {
        await submitPipelineWithReset(new FormData(boundElement));
        return;
      }
      if (options?.resetOnSuccess && formData && !submitting.peek()) {
        const hasErrors = [...fieldCache.values()].some((f) => f.error.peek() !== undefined);
        if (!hasErrors && boundElement) {
          boundElement.reset();
        }
      }
    },
    submitting,
    dirty,
    valid,
    __bindElement: (el: HTMLFormElement) => {
      boundElement = el;
      el.addEventListener('input', handleInputOrChange);
      el.addEventListener('change', handleInputOrChange);
      el.addEventListener('focusout', handleFocusout);
    },
  };

  const knownProperties = new Set(Object.keys(baseProperties));

  return new Proxy(baseProperties, {
    get(target, prop, receiver) {
      if (typeof prop === 'string') {
        if (knownProperties.has(prop)) {
          return target[prop];
        }
        return getOrCreateField(prop);
      }
      return Reflect.get(target, prop, receiver);
    },
  }) as FormInstance<TBody, TResult>;
}
